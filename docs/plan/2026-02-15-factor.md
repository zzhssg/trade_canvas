---
title: factor 全链路真插件化一次性重构
status: 待验收
owner: codex
created: 2026-02-15
updated: 2026-02-15
---

## 背景

当前因子写链路已具备 bundle 自动发现，但仍存在 4 个阻断点：
1. 因子运行时状态（tick/rebuild/head）仍以 pivot/pen/zhongshu/anchor/sr 硬编码字段驱动，新增因子需要改 orchestrator 与状态结构。
2. Overlay renderer 仍在 `renderer_plugins.py` 手工注册，新增渲染器需要改中心清单。
3. 前端 overlay 消费对 `pivot.major` / `anchor.switch` / `pen.confirmed` 强绑定，新因子即使产出 overlay 指令也不会自动渲染。
4. 因子 capability 默认关闭 feature/freqtrade/backtest 开关，新增因子不能默认进入指标物化链路。

这导致“新增一个因子”无法做到最小改动，也无法保证因子→实盘/回测/freqtrade/冷热分析链路一致。

## 目标 / 非目标

### 目标
- 新增因子时，不改中心注册文件即可进入：factor 写链路 + slices + overlay 指令渲染 + feature 物化 + freqtrade 读取。
- 运行时状态改为因子命名空间容器，移除 orchestrator 级别的因子字段扩散。
- 前端改为指令驱动渲染，避免按因子名硬编码渲染入口。
- 保持已有 pivot/pen/zhongshu/anchor/sr 行为与回归测试稳定。

### 非目标（YAGNI）
- 本轮不重做算法逻辑（pivot/pen/sr 计算规则不改）。
- 本轮不引入第二套 overlay 协议（只保留现有 draw/overlay 指令协议）。
- 本轮不改 replay 文件格式 schema_version（仅保持兼容读取）。
- 何时再评估：当需要新增非 marker/polyline 的 overlay 类型（例如 heatmap/box）时再升级协议。

## 两次设计（Design it Twice）

### 方案 A（推荐）：保留协议，重构运行时与发现机制
- 核心：
  - 引入因子命名空间状态容器（tick/rebuild/head 共用），旧字段改为兼容属性映射到命名空间。
  - overlay renderer 改为模块自动发现（按 `renderer_*.py` + `build_renderer_plugin()`）。
  - 前端 marker/polyline 全量走通用 feature 渲染，pen/anchor 高亮仅作为增强层。
  - capability 默认策略改为“默认全链路开启，可按需 override 关闭”。
- 优势：
  - 契约稳定（P6），新增因子只新增文件（P4/P14）。
  - 回滚成本低：可按模块 revert（runtime/overlay/frontend/capability）。
  - 验收成本可控：现有测试可复用并补充少量回归。
- 风险：
  - 需要同时改 FE+BE 多模块，实施窗口较大。

### 方案 B：引入统一 Factor SDK/声明式 schema，再重写 FE/BE 消费
- 核心：统一声明 event->slice->overlay->feature->freqtrade 全链路 DSL，由代码生成器产物。
- 优势：长期一致性强。
- 劣势：一次性替换范围过大，验收成本与回滚成本高，当前仓库无完整生成链路。

### 取舍结论
选 **方案 A**。它在不引入新双轨的前提下，能一次性打通全链路插件化，并保持当前协议稳定与可回滚。

## 架构与边界

- 依赖方向保持：`ingest -> store -> factor -> overlay -> read_model -> route`。
- 新增状态容器只在 factor 内部传播，`read_model/route` 不感知内部状态组织。
- overlay renderer 自动发现只在 `backend/app/overlay` 内闭环。
- 前端只消费 overlay 指令与 factor slices，不反向依赖具体因子实现文件。

## 数据流与契约

- `candle_id` 口径保持不变。
- `FactorTickState` / `FactorBootstrapState` / `HeadBuildState` 增加 `factor_state(factor_name)` 命名空间 API。
- `FactorTickExecutionResult` 增加 `factor_states`（命名空间快照）以贯通 bootstrap->tick->head。
- overlay 指令保持 `marker`/`polyline` 结构不变，前端按 `definition.feature` 统一过滤和渲染。

## 任务拆解（原子可回滚）

1. **后端 runtime 状态插件化（核心）**
   - 改什么：`backend/app/factor/tick_executor.py`、`backend/app/factor/rebuild_loader.py`、`backend/app/factor/ingest_outputs.py`、`backend/app/factor/orchestrator_ingest.py`。
   - 验收：`pytest -q backend/tests/test_factor_tick_executor.py backend/tests/test_factor_orchestrator_settings.py`
   - 回滚：`git revert <runtime-commit-sha>`
   - 删什么：`backend/app/factor/tick_state_slices.py`（移除硬编码状态切片结构）

2. **Overlay renderer 自动发现**
   - 改什么：`backend/app/overlay/renderer_plugins.py` + 各 renderer 模块增加统一工厂。
   - 验收：`pytest -q backend/tests/test_overlay_renderer_plugins.py`
   - 回滚：`git revert <overlay-commit-sha>`
   - 删什么：手工插件列表实现。

3. **Capability 默认策略统一**
   - 改什么：`backend/app/factor/capability_manifest.py`、相关测试。
   - 验收：`pytest -q backend/tests/test_factor_capability_manifest.py backend/tests/test_feature_orchestrator.py`
   - 回滚：`git revert <capability-commit-sha>`
   - 删什么：新增因子必须手工 override 才能 feature 化的默认路径。

4. **前端指令驱动渲染去硬编码**
   - 改什么：`frontend/src/widgets/chart/overlayRuntimeCore.ts`、`frontend/src/widgets/chart/overlayCallbackRuntime.ts`、`frontend/src/widgets/chart/chartOverlayCallbacks.ts`、`frontend/src/widgets/chart/seriesSyncRuntime.ts`。
   - 验收：`cd frontend && npm run build`
   - 回滚：`git revert <frontend-commit-sha>`
   - 删什么：`pivot/anchor` 专用 marker 渲染主路径。

5. **freqtrade 策略入口修复 + 回归**
   - 改什么：`Strategy/TradeCanvasFactorLedgerStrategy.py` + 新增回归测试。
   - 验收：`pytest -q backend/tests/test_freqtrade_adapter_v1.py`
   - 回滚：`git revert <freqtrade-commit-sha>`

## E2E 用户故事（tc-e2e-gate）

- Persona：量化策略开发者。
- Goal：新增一个因子插件后，不改中心注册文件，主链路可自动出现在图表与 feature/freqtrade 消费中。
- 入口：新增 `backend/app/factor/bundles/demo_factor.py`（测试内构造）并触发一次 closed candle ingest。
- 主流程断言：
  1) factor manifest 自动包含新因子；
  2) factor 事件进入 store；
  3) overlay 指令能按 feature 自动渲染；
  4) feature 物化默认包含该因子事件计数；
  5) freqtrade adapter 可读取对应 feature bucket。
- 证据命令：
  - `pytest -q`
  - `cd frontend && npm run build`
  - `bash scripts/e2e_acceptance.sh`（若环境可运行）
- 产物路径：`output/playwright/`（若执行 e2e_acceptance）。

## 复杂度与红旗自检

### P-Card 落地
- `P4` 深模块：状态复杂度下沉到命名空间容器，orchestrator 只管调度。
- `P6` 接口简于实现：新增因子只需实现插件接口，不需理解全局状态字段。
- `P10` 定义错误不存在：通过统一 `factor_state()` API 避免“忘记加字段”类错误。
- `P11` 设计两次：本计划已完成 A/B 取舍。
- `P14` 抽象增量：先统一发现/状态抽象，再保留既有算法。

### R-Card 排查
- `R1` 浅模块：通过状态容器避免 orchestrator 继续膨胀（修复）。
- `R2` 信息泄漏：renderer 注册从中心清单改为模块自注册（修复）。
- `R3` 时间分解：前端由“先分 marker 类型再渲染”改为“按指令契约渲染”（修复）。
- `R5` 透传方法：减少硬编码 rebuild 函数分叉（修复）。
- `R6` 重复实现：pivot/anchor marker 解析逻辑合并为统一 marker 解析（修复）。
- `R7` 通用/专用混杂：pen/anchor 高亮留在增强层，基础渲染通用化（修复）。
- `R11` 命名模糊：新增 `factor_states` 命名统一，避免新增 `xxx_state` 字段泛滥。
- `R13` 非显而易见代码：为状态容器与 discovery 加 fail-fast 错误码。

## 风险与回滚

- 风险 1：状态映射改造导致老因子行为漂移。
  - 缓解：保留属性映射兼容层（仅内部），并用现有因子回归覆盖。
- 风险 2：前端 marker 合并导致可见性开关异常。
  - 缓解：按 `feature` 精确过滤并保留父子开关逻辑。
- 风险 3：环境缺少前端编译器导致 build 无法执行。
  - 缓解：先补装依赖后再执行 `npm run build`，无法执行时在证据中明确阻塞点。

回滚策略：按上面 5 个原子步骤逐个 `git revert`，无需手工补丁。

## 验收标准

- `pytest -q`
- `cd frontend && npm run build`
- `bash scripts/quality_gate.sh`
- `bash docs/scripts/doc_audit.sh`
- 若改动触及 FE+BE 主链路：`bash scripts/e2e_acceptance.sh`

## 变更记录
- 2026-02-15: 创建计划，完成 A/B 设计与 E2E 门禁定义。
