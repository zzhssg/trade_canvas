---
title: 第29关：从 0 到 1，这个项目是怎么长成这样的
status: done
created: 2026-02-11
updated: 2026-02-11
---

# 第29关：从 0 到 1，这个项目是怎么长成这样的

上一关你学了"数据库设计的取舍"。这一关换个视角：

**不看单个模块，看整个系统是怎么从一个空目录，一步步长成你现在看到的样子的。**

很多人学架构，只看"最终形态"——就像看一栋大楼的竣工照片。但真正有价值的是施工过程：先打地基还是先搭框架？哪面墙是后来加的？哪个决策避免了返工？

trade_canvas 的演进可以分成五个阶段。每个阶段都有一个核心痛点，一个关键决策，和一个明确的产物。

想象你在看一棵树的年轮：每一圈都是一年的生长，内圈是最早的，外圈是最新的。你不能跳过内圈直接长外圈——每一层都是下一层的基础。

---

## 0. 先给一句总纲

架构不是设计出来的，是演进出来的。但演进不是随机生长——每一步都要守住一个核心约束，解决一个真实痛点。

trade_canvas 的五个阶段：

1. **MVP**：确立"closed candle 是唯一权威输入"
2. **单路径编排**：用 IngestPipeline 串联写链路
3. **实时链路**：WS 摄取 + 作业调度 + 市场数据域
4. **读写分离**：冷热账本 + DAG 调度 + 读模型层
5. **架构硬化**：DI 容器 + 插件化 + 配置真源 + 边界测试

---

## 1. 第一阶段：MVP——先让数据流起来

**痛点**：从零开始，需要快速验证"K 线 → 因子 → 图表"这条链路能不能跑通。

**关键决策**：

- 技术栈选 FastAPI + SQLite + React——轻量、单机可跑、开发快；
- 定下第一条铁律：**closed candle 是唯一权威输入**，forming candle 只用于展示，不进因子引擎、不落库。

**为什么这条铁律如此重要？**

年轮比喻：这是树的第一圈年轮——最内层。如果这一圈歪了，后面每一圈都会跟着歪。

如果 forming candle 也进因子引擎，你会遇到：

- 同一根 K 线在未收线时算一次、收线后又算一次，结果不一致；
- 回测和实盘的输入不同，可复现性直接崩塌；
- 所有下游都要处理"这根 K 线可能会变"的复杂性。

一条简单的约束，砍掉了一整类复杂性。

**产物**：基础的前后端分离架构，K 线存储与查询，初步的因子计算。

---

## 2. 第二阶段：单路径编排——把散落的逻辑串成一条线

**痛点**：因子计算和图表渲染的顺序不确定。有时候图画出来了但因子没更新，有时候因子算了但图没刷新。

**关键决策**：引入 `IngestPipeline` 作为唯一的写链路编排器，确立 sidecar 顺序不变量：

```text
candles → factor → overlay → publish
```

年轮比喻：第二圈年轮。有了权威输入（第一圈），现在需要一条确定的处理路径。

**为什么不让各模块自己监听事件、各自处理？**

因为事件驱动的松耦合在这里是个陷阱。当你有三个模块需要严格按顺序执行时，"各自监听"会导致：

- 顺序不确定（谁先收到事件？）；
- 失败语义不清（factor 失败了，overlay 该不该继续？）；
- 补偿逻辑无处安放（谁负责回滚？）。

单路径编排看起来"不够优雅"，但它让失败语义、补偿逻辑、执行顺序全部变得确定。

**产物**：`pipelines/ingest_pipeline.py`，以及初步的 `FactorOrchestrator` 和 `OverlayOrchestrator`。

---

## 3. 第三阶段：实时链路——从"手动灌数据"到"自动摄取"

**痛点**：

- 前端需要实时看到 K 线跳动，但只有 HTTP 轮询；
- 市场数据的摄取、订阅管理、缺口修复散落在多个地方；
- 没有"按需摄取"——用户切换品种时，后端不知道该开始摄取哪个品种。

**关键决策**：

- 引入 Binance WS 实时摄取 + `IngestSupervisor` 管理作业生命周期；
- 新增 `forming` 事件类型（WS-only），让未收线 K 线能跳动；
- 引入 `WsSubscriptionCoordinator` 统一管理前端订阅。

年轮比喻：第三圈。有了写链路（第二圈），现在需要一个"自动喂数据"的机制。

**一个重要的架构约束**：forming 事件只走 WS 推送，不进 IngestPipeline，不落库。这保持了第一阶段定下的铁律——closed candle 是唯一权威输入。

**产物**：`ingest_supervisor.py`、`ingest_binance_ws.py`、`market_data/` 目录。

---

## 4. 第四阶段：读写分离——从"读写混在一起"到"冷热账本"

**痛点**：

- 读路径和写路径混在一起，读的时候可能触发隐式重算；
- 因子之间的依赖关系（pivot → pen → zhongshu）没有显式表达；
- 无法支持 replay——因为 replay 需要"定点切片"，而当前的读取会混入最新数据。

**关键决策**：

- 引入 `FactorGraph`：显式的 DAG 依赖管理与拓扑排序；
- 分离读模型层：`FactorReadService` / `DrawReadService` / `WorldReadService`；
- 引入冷热账本概念：冷（append-only 事件）用于切片，热（head 快照）用于点查。

年轮比喻：第四圈。这是最关键的一次"结构性升级"——从"能跑"到"跑得对"。

**为什么读写分离在这个阶段才做？**

因为过早分离会增加复杂性，而你还没有足够的场景来验证分离的边界在哪里。等到 replay 需求出现时，"读路径不能触发隐式重算"这个约束才变得清晰。

**产物**：`factor_graph.py`、`read_models/` 目录、`factor_rebuild_loader.py`。

---

## 5. 第五阶段：架构硬化——从"能跑"到"改不坏"

**痛点**：

- 配置散落在 `os.environ` 各处，行为不可预测；
- 依赖注入不清晰，路由层直接访问 `app.state`；
- 新增因子需要改 orchestrator 代码，扩展性差；
- 没有边界测试，架构约束只靠口头约定。

**关键决策**：

- 统一配置真源：`FeatureFlags`（功能开关）+ `RuntimeFlags`（运行时参数）；
- 引入 `AppContainer`：集中装配所有依赖；
- 完全插件化：`FactorPluginRegistry` + `OverlayRendererPlugins`；
- 引入边界测试：`test_app_state_boundary.py` 禁止越层访问。

年轮比喻：第五圈——最外层。这一层不是加功能，而是加护栏。让前四层的成果不会在后续迭代中被意外破坏。

**为什么插件化放在最后？**

因为过早抽象会导致"为了灵活而灵活"。等你有了 pivot、pen、zhongshu、anchor 四个真实因子后，插件接口的形状才真正清晰。

**产物**：`container.py`、`market_runtime_builder.py`、`flags.py`、`runtime_flags.py`、边界测试套件。

---

## 6. 三个关键转折点

回头看这五个阶段，有三个转折点决定了系统的最终形态：

### 转折 1：从"散落逻辑"到"单路径编排"（阶段 1→2）

问题是顺序不确定。解决方案是 `IngestPipeline` 作为唯一编排器。

这个决策的深远影响：后续所有的补偿逻辑、幂等设计、错误分层，都建立在"写链路只有一条路"这个前提上。如果当初选了事件驱动的松耦合，这些后续设计会复杂十倍。

### 转折 2：从"读写混合"到"冷热账本"（阶段 3→4）

问题是读路径会触发隐式重算。解决方案是读写分离 + 冷热账本。

这个决策让 replay 成为可能——因为 replay 本质上就是"在历史某个时间点做一次纯读取"。如果读路径会触发写入，replay 的结果就不可复现。

### 转折 3：从"隐式依赖"到"显式容器"（阶段 4→5）

问题是配置和依赖散落各处。解决方案是 `AppContainer` + `RuntimeFlags`。

这个决策让系统变得可测试——因为所有依赖都是显式注入的，单测可以轻松替换任何一个组件。

---

## 7. 为什么不用 PostgreSQL / Redis / 微服务？

这是初学者最常问的问题。答案很简单：

| 方案 | 为什么没选 |
| ---- | ---------- |
| PostgreSQL | 单机开发不需要 C/S 架构的数据库，SQLite 够用且零运维 |
| Redis | 没有需要跨进程共享的热数据，进程内状态足够 |
| 微服务 | 只有一个开发者，拆服务只会增加部署和调试成本 |
| 事件总线 | 写链路需要严格顺序，事件驱动反而增加复杂性 |

这些技术不是"不好"，而是"在当前规模下不需要"。

架构决策的核心原则：**选择当前规模下最简单的方案，但保留演进到更复杂方案的路径。**

比如：SQLite 三库分离的设计，未来如果需要迁移到 PostgreSQL，只需要替换 store 层的实现，上层的 orchestrator 和 read service 完全不用改——因为它们只依赖 store 的接口，不依赖 SQLite 的细节。

---

## 8. 你可以从中学到的演进方法论

把这五个阶段抽象成通用模板：

1. **先定核心约束**：找到系统里"一旦错了就全盘皆输"的那条规则，最早确立。
2. **先串联再优化**：先用最简单的方式把主链路跑通，再考虑性能和扩展。
3. **痛点驱动重构**：不要"预防性重构"——等真实痛点出现时再动手，这样你才知道边界在哪。
4. **约束先于抽象**：先用测试钉死边界，再考虑插件化和抽象。
5. **每一步都可回滚**：每个阶段的改动都是独立的，可以单独验证和回退。

---

## 9. 代码锚点（按演进阶段）

- 阶段 1-2（写链路）
  - `backend/app/pipelines/ingest_pipeline.py`
  - `backend/app/store.py`
  - `backend/app/factor_orchestrator.py`
  - `backend/app/overlay_orchestrator.py`
- 阶段 3（实时链路）
  - `backend/app/ingest_supervisor.py`
  - `backend/app/ingest_binance_ws.py`
  - `backend/app/market_data/`
- 阶段 4（读写分离）
  - `backend/app/factor_graph.py`
  - `backend/app/factor_tick_executor.py`
  - `backend/app/read_models/`
  - `backend/app/factor_rebuild_loader.py`
- 阶段 5（架构硬化）
  - `backend/app/container.py`
  - `backend/app/market_runtime_builder.py`
  - `backend/app/flags.py`
  - `backend/app/runtime_flags.py`
  - `backend/tests/test_app_state_boundary.py`
- 架构文档
  - `docs/core/architecture.md`
  - `docs/core/backend-chain-breakdown.md`

---

## 10. 过关自测

1. 为什么"closed candle 是唯一权威输入"这条约束要在最早期确立？
2. 单路径编排相比事件驱动，在失败语义上的核心优势是什么？
3. 读写分离为什么不在第一阶段就做，而是等到 replay 需求出现？
4. 插件化为什么放在最后一个阶段？过早抽象的风险是什么？
5. 如果让你从零开始做一个类似系统，你会保留哪些决策、改变哪些决策？

如果这 5 题你能讲清楚，你已经从"看懂别人的架构"进阶到"能规划自己的架构演进路径"。
