---
title: 第6关：从分析到下单——回测为什么是量化的命根子
status: done
created: 2026-02-11
updated: 2026-02-11
---

# 第6关：从分析到下单——回测为什么是量化的命根子

前两关你学会了 K 线（数据语言）和缠论（分析方法）。

现在你有了一套分析方法，能从 K 线里看出趋势和中枢。下一步自然是：**用这套方法去交易，赚钱。**

但等等——你敢直接拿真金白银去试吗？

不敢。就像你刚学会开车，不会直接上高速。你得先在驾校的模拟器上练。

量化交易的"模拟器"就是**回测**（Backtest）。

---

## 1. 回测是什么：用昨天的数据考今天的策略

回测的核心思路极其简单：

> 把你的交易策略放到历史数据上跑一遍，看看如果你从去年 1 月 1 日开始用这个策略，到今天能赚多少钱（或亏多少钱）。

就像考试前做往年真题。你不是在预测今年考什么，而是在检验"我的解题方法靠不靠谱"。

- 做了 10 套真题，8 套都能 80 分以上 → 方法大概率靠谱
- 做了 10 套真题，5 套不及格 → 方法有问题，别上考场

回测就是量化交易的"往年真题"。

---

## 2. 一次回测的完整流程

在这个系统里，回测的流程是这样的：

```text
第①步              第②步              第③步              第④步
选策略+交易对  →  加载历史K线  →  逐根蜡烛模拟  →  统计成绩单
(你要考什么)     (拿出真题卷)    (一题一题做)     (算总分)
```

### 第①步：选策略和交易对

用户在前端选择：
- 用哪个策略（比如"缠论突破策略"）
- 看哪个交易对（比如 BTC/USDT）
- 用什么时间框架（比如 1 小时线）
- 回测哪段时间（比如 2025 年全年）

```typescript
// frontend/src/parts/BacktestPanel.tsx
const runMutation = useMutation({
  mutationFn: (payload: BacktestRunRequest) =>
    apiJson<BacktestRunResponse>("/api/backtest/run", {
      method: "POST",
      body: JSON.stringify(payload)
    })
});
```

### 第②步：加载历史 K 线

系统从本地数据库或 Freqtrade 的数据文件中加载这段时间的所有 K 线。

这就像老师把往年真题卷从档案室里拿出来。没有真题，就没法模拟考试。

### 第③步：逐根蜡烛模拟交易

这是回测的核心。系统假装时间倒流，从第一根 K 线开始，一根一根往后走：

- 看到第 1 根蜡烛 → 策略说"不买" → 跳过
- 看到第 50 根蜡烛 → 策略说"买入！" → 记录买入价格
- 看到第 80 根蜡烛 → 策略说"卖出！" → 记录卖出价格，算盈亏
- ……一直到最后一根蜡烛

关键规则：**策略在第 N 根蜡烛做决策时，只能看到前 N 根蜡烛的数据，不能偷看后面的。**

这就像做真题时不能翻答案。如果你做第 3 题的时候偷看了第 4 题的答案，那你的"成绩"就是假的。

这个系统用 Freqtrade（一个开源的量化交易框架）来执行回测：

```python
# backend/app/freqtrade_runner.py
command = [
    sys.executable, "-c", code,
    "backtesting",
    "--strategy", strategy_name,    # 用哪个策略
    "--timeframe", timeframe,       # 什么时间框架
    "--pairs", pair,                # 什么交易对
    "--timerange", timerange,       # 回测哪段时间
    "--export", "trades",           # 导出交易记录
]
proc = subprocess.run(command, capture_output=True, text=True)
```

### 第④步：统计成绩单

回测跑完后，系统会生成一份"成绩单"，包含：

- 总盈亏（赚了还是亏了）
- 胜率（多少笔交易是赚钱的）
- 最大回撤（最惨的时候亏了多少）
- 夏普比率（风险调整后的收益）

```python
# backend/app/schemas.py
class BacktestRunResponse(BaseModel):
    ok: bool              # 回测是否成功执行
    exit_code: int        # 进程退出码
    duration_ms: int      # 跑了多久
    stdout: str           # 成绩单（Freqtrade 的文本输出）
    stderr: str           # 错误信息（如果有的话）
```

---

## 3. 回测的三个致命陷阱

回测听起来很美好，但有三个坑，掉进去就白忙活：

### 陷阱一：过拟合——"背答案"

你调了 20 个参数，让策略在 2025 年的数据上完美盈利。但换到 2024 年的数据就亏得一塌糊涂。

这就像你把去年的真题答案背下来了，但今年换了题目，你还是不会做。

解决办法：把数据分成"训练集"和"测试集"。用训练集调参数，用测试集验证。

### 陷阱二：未来函数——"偷看答案"

策略在做决策时，不小心用到了"未来的数据"。比如用了当天的收盘价来决定当天开盘时要不要买。

这就是为什么系统有铁律"closed 才算数"——只有收盘的蜡烛才能参与计算，正在跳动的蜡烛不行。

### 陷阱三：幸存者偏差——"只看赢家"

你只回测了 BTC/USDT，发现策略很赚钱。但你没测 ETH/USDT、SOL/USDT……也许策略只是碰巧在 BTC 上有效。

解决办法：多交易对、多时间框架、多时间段交叉验证。

---

## 4. 回放：比回测更直观的"录像回放"

回测告诉你"最终成绩"，但不告诉你"过程中发生了什么"。

你想知道：策略在第 50 根蜡烛买入的时候，当时的 pivot、pen、zhongshu 是什么状态？为什么策略判断"该买了"？

这就是**回放**（Replay）的用途——它不只是跑一遍策略，而是把整个因子计算过程"录像"下来，让你一帧一帧地回看。

```text
回测 = 考完试看总分
回放 = 考完试看每道题的解题过程
```

### 回放的工作流程

```text
第①步                第②步              第③步              第④步
检查数据覆盖率  →  构建回放包  →  分窗口打快照  →  前端逐帧播放
(真题够不够)      (录制解题过程)  (每10题存一个档)  (一题一题回看)
```

**第①步：检查覆盖率**

回放需要连续的 K 线数据。如果中间有缺口（比如某天的数据丢了），就像真题卷缺了几页，没法完整回放。

```python
# backend/app/replay_package_protocol_v1.py
class ReplayCoverageV1(BaseModel):
    required_candles: int      # 需要多少根蜡烛
    candles_ready: int         # 已经有多少根
```

如果不够，系统会自动从 Freqtrade 或交易所补数据。

**第②步：构建回放包**

系统把所有 K 线按顺序喂进因子流水线，记录每一步的计算结果——pivot 在哪里确认了、pen 在哪里成笔了、zhongshu 在哪里形成了。

**第③步：分窗口打快照**

如果有 1000 根蜡烛，不可能把 1000 帧的数据一次性全加载到前端。系统把它们分成若干"窗口"，每个窗口包含一段蜡烛和对应的因子快照。

```python
# backend/app/replay_package_protocol_v1.py
class ReplayWindowV1(BaseModel):
    window_index: int                    # 第几个窗口
    kline: list[ReplayKlineBarV1]        # 这个窗口的K线
    draw_catalog_base: list[...]         # 基础绘图指令
    draw_catalog_patch: list[...]        # 增量绘图指令
```

就像视频播放器：不是把整部电影一次性下载完，而是边看边缓冲，每次加载一小段。

**第④步：前端逐帧播放**

前端拿到窗口数据后，用播放器的方式展示：

```typescript
// frontend/src/parts/ReplayPanel.tsx
<button onClick={() => setPlaying(!playing)}>
  {playing ? "Pause" : "Play"}
</button>

<input type="range" min={0} max={sliderMax} value={index}
       onChange={(e) => setIndex(Number(e.target.value))} />
```

你可以播放、暂停、拖动进度条、调整速度——就像看视频一样回看整个交易过程。

---

## 5. 回测和回放的关系

| 维度 | 回测（Backtest） | 回放（Replay） |
| ---- | ---- | ---- |
| 目的 | 验证策略盈亏 | 理解因子过程 |
| 输出 | 成绩单（盈亏/胜率/回撤） | 录像（逐帧因子状态） |
| 引擎 | Freqtrade（外部工具） | 自建因子流水线 |
| 交互 | 跑完看结果 | 可播放/暂停/拖动 |
| 比喻 | 做完真题看总分 | 回看每道题的解题过程 |

它们是互补的：回测告诉你"策略行不行"，回放告诉你"策略为什么行（或不行）"。

---

## 6. 为什么说回测是"命根子"

没有回测的量化交易，就是赌博。

- 你觉得"中枢突破就该买入"？回测一下，看看历史上这么做赚了还是亏了。
- 你觉得"窗口设 5 比设 10 好"？回测一下，用数据说话。
- 你觉得"这个策略在牛市和熊市都能赚"？回测一下，分别跑牛市和熊市的数据。

回测不能保证未来一定赚钱（过去的表现不代表未来），但它能帮你淘汰掉那些"在历史上就不行"的策略。

就像体检不能保证你不生病，但能帮你发现已经存在的问题。

---

## 7. 代码锚点

| 概念 | 文件 | 干什么的 |
| ---- | ---- | ---- |
| 回测 API | `backend/app/backtest_routes.py` | 三个回测端点 |
| 回测服务 | `backend/app/backtest_service.py` | 回测核心逻辑 |
| Freqtrade 调用 | `backend/app/freqtrade_runner.py` | 执行回测命令 |
| 因子适配器 | `backend/app/freqtrade_adapter_v1.py` | 因子与回测的桥接 |
| 回放服务 | `backend/app/replay_package_service_v1.py` | 回放包构建 |
| 回放协议 | `backend/app/replay_package_protocol_v1.py` | 回放数据结构 |
| 前端回测面板 | `frontend/src/parts/BacktestPanel.tsx` | 回测 UI |
| 前端回放面板 | `frontend/src/parts/ReplayPanel.tsx` | 回放播放器 |
| 回测数据结构 | `backend/app/schemas.py` | 请求/响应格式 |

---

## 8. 过关自测

如果你能用自己的话回答这五个问题，第 6 关就过了：

1. 回测的核心思路是什么？用"做往年真题"的比喻解释。
2. 为什么回测时策略不能"偷看未来的数据"？这和系统的哪条铁律相关？
3. "过拟合"是什么？用"背答案"的比喻解释。
4. 回测和回放的区别是什么？它们分别回答什么问题？
5. 为什么说"没有回测的量化交易就是赌博"？
