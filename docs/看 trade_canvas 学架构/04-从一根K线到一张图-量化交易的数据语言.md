---
title: 第4关：从一根K线到一张图——量化交易的数据语言
status: done
created: 2026-02-11
updated: 2026-02-11
---

# 第4关：从一根K线到一张图——量化交易的数据语言

前三关你已经知道了系统的全貌、术语的含义、学习的路径。

但有一个问题一直悬着：**这个系统到底在处理什么数据？为什么数据长这个样子？**

你可能听过"K 线"、"蜡烛图"、"交易对"这些词，但如果你不懂金融，它们就像外星语。

这一关，我们从零开始，把量化交易的数据语言讲清楚。读完这篇，你再看代码里的 `open`、`high`、`low`、`close`，就不再是四个莫名其妙的浮点数了。

---

## 1. 从菜市场说起：什么是"交易"

你去菜市场买白菜。

- 早上 8 点，白菜 2 块钱一斤。
- 9 点，来了一车新鲜的，降到 1.8。
- 10 点，快收摊了，涨到 2.5。
- 11 点，收摊，最后一笔成交价 2.3。

这四个价格，就是白菜在今天上午的"行情"。

把"白菜"换成"比特币"，把"菜市场"换成"币安交易所"，把"上午"换成"1 分钟"——你就得到了一根 K 线。

---

## 2. 一根 K 线：四个价格 + 一个成交量

一根 K 线记录的是**某个时间段内**的交易摘要。不管这一分钟里发生了几千笔交易，最终浓缩成五个数字：

| 字段 | 英文 | 含义 | 白菜版 |
| ---- | ---- | ---- | ---- |
| 开盘价 | open | 这段时间第一笔成交的价格 | 早上第一笔：2 块 |
| 最高价 | high | 这段时间内的最高成交价 | 最贵的时候：2.5 块 |
| 最低价 | low | 这段时间内的最低成交价 | 最便宜的时候：1.8 块 |
| 收盘价 | close | 这段时间最后一笔成交的价格 | 收摊价：2.3 块 |
| 成交量 | volume | 这段时间总共成交了多少 | 今天卖了 500 斤 |

在代码里，这五个数字被打包成一个对象：

```python
# backend/app/schemas.py
class CandleClosed(BaseModel):
    candle_time: int    # 这根K线的开始时间（Unix秒）
    open: float         # 开盘价
    high: float         # 最高价
    low: float          # 最低价
    close: float        # 收盘价
    volume: float       # 成交量
```

就这么简单。一根 K 线 = 一个时间戳 + 五个数字。

---

## 3. 为什么叫"蜡烛"：画出来你就懂了

这五个数字画在图上，长得像一根蜡烛：

```text
     ┃          ← 上影线（最高价到开盘/收盘价之间的线）
   ┏━┛
   ┃  ┃        ← 实体（开盘价和收盘价之间的方块）
   ┗━┓
     ┃          ← 下影线（最低价到开盘/收盘价之间的线）

   涨了？实体是绿色（或空心）。
   跌了？实体是红色（或实心）。
```

为什么用蜡烛而不是折线图？因为一根蜡烛能同时告诉你四件事：开在哪、收在哪、最高到哪、最低到哪。折线图只能告诉你一件事（通常是收盘价）。

信息密度差了四倍。

前端用 Lightweight Charts 这个库来画蜡烛：

```typescript
// frontend/src/widgets/chart/useLightweightChart.ts
const chart = createChart(container, {
  layout: { background: { color: "#0b0f14" }, textColor: "#c9d1d9" },
  // ...
});
const series = chart.addSeries(CandlestickSeries);  // 添加蜡烛图系列
```

后端传过来的数据要转换一下格式才能喂给图表库：

```typescript
// frontend/src/widgets/chart/candles.ts
export function toChartCandle(c: CandleClosed): Candle {
  return {
    time: c.candle_time as UTCTimestamp,  // 时间戳
    open: c.open,    // 开盘价
    high: c.high,    // 最高价
    low: c.low,      // 最低价
    close: c.close   // 收盘价（注意：volume 不传，蜡烛图不需要）
  };
}
```

---

## 4. 时间框架：同一段行情的不同"分辨率"

同一段行情，你可以用不同的"放大镜"去看：

- **1 分钟线（1m）**：每分钟一根蜡烛。像用显微镜看，细节很多，但容易迷失在噪音里。
- **5 分钟线（5m）**：每 5 分钟一根。稍微退后一步看。
- **1 小时线（1h）**：每小时一根。看大趋势。
- **1 日线（1d）**：每天一根。看长期走势。

就像看地图：1m 是街道地图，能看到每个路口；1d 是省级地图，只能看到城市之间的高速公路。

这个系统支持的时间框架：

```typescript
// frontend/src/parts/ChartPanel.tsx
const TIMEFRAMES = ["1m", "5m", "15m", "1h", "4h", "1d"] as const;
```

用户在界面上点一个按钮就能切换：

```typescript
{timeframeOptions.map((tf) => (
  <button
    key={tf}
    aria-pressed={timeframe === tf}
    onClick={() => setTimeframe(tf)}
  >
    {tf}
  </button>
))}
```

### 衍生时间框架：从 1 分钟"拼"出 5 分钟

系统只从币安接收 1 分钟线。那 5 分钟线、1 小时线从哪来？

**拼出来的。**

5 根 1 分钟蜡烛拼成 1 根 5 分钟蜡烛。规则很直觉：

- 开盘价 = 第 1 根的开盘价（第一笔交易）
- 收盘价 = 第 5 根的收盘价（最后一笔交易）
- 最高价 = 5 根里最高的那个
- 最低价 = 5 根里最低的那个
- 成交量 = 5 根加起来

```python
# backend/app/derived_timeframes.py
def _merge_candles_to_derived(*, bucket_open_time, minutes):
    first = minutes_sorted[0]
    last = minutes_sorted[-1]
    return CandleClosed(
        candle_time=int(bucket_open_time),
        open=float(first.open),                                     # 第一根的开盘价
        high=float(max(float(c.high) for c in minutes_sorted)),    # 最高的最高价
        low=float(min(float(c.low) for c in minutes_sorted)),      # 最低的最低价
        close=float(last.close),                                    # 最后一根的收盘价
        volume=float(sum(float(c.volume) for c in minutes_sorted)), # 成交量求和
    )
```

就像把 5 张日报合并成 1 张周报：标题用周一的，结尾用周五的，大事件取最重要的。

---

## 5. 交易对：谁和谁换

"BTC/USDT"是一个交易对。斜杠左边是你要买的东西（BTC，比特币），右边是你用来付钱的东西（USDT，一种锚定美元的稳定币）。

就像菜市场的标价牌写着"白菜/人民币"——你用人民币买白菜。

系统用 `SeriesId` 来唯一标识一条数据流：

```python
# backend/app/series_id.py
@dataclass(frozen=True)
class SeriesId:
    exchange: str      # "binance"——哪家交易所（哪个菜市场）
    market: str        # "futures"——期货还是现货（批发还是零售）
    symbol: str        # "BTC/USDT"——什么交易对（买什么用什么付）
    timeframe: str     # "1m"——几分钟一根（多久记一次价）
```

四个维度组合起来，就是一条唯一的数据流。`binance:futures:BTC/USDT:1m` 和 `binance:spot:BTC/USDT:1m` 是两条不同的流——虽然都是 BTC/USDT 的 1 分钟线，但一个是期货市场的，一个是现货市场的，价格不一样。

### 现货 vs 期货：零售 vs 批发

- **现货（spot）**：一手交钱一手交货。你花 36000 USDT 买 1 个 BTC，BTC 立刻到你账户。
- **期货（futures）**：先签合同，到期再交割。你可以用 3600 USDT 的保证金，撬动 36000 USDT 的 BTC（10 倍杠杆）。赚得多，亏得也快。

系统在界面上提供了切换按钮：

```typescript
// frontend/src/parts/ChartPanel.tsx
<button aria-pressed={market === "spot"} onClick={() => setMarket("spot")}>
  Spot
</button>
<button aria-pressed={market === "futures"} onClick={() => setMarket("futures")}>
  Futures
</button>
```

---

## 6. 数据怎么存：SQLite 里的一张表

所有 K 线都存在 SQLite 数据库的一张表里：

```sql
-- backend/app/store.py
CREATE TABLE IF NOT EXISTS candles (
  series_id   TEXT    NOT NULL,   -- "binance:futures:BTC/USDT:1m"
  candle_time INTEGER NOT NULL,   -- 1707000000（Unix秒）
  open        REAL    NOT NULL,   -- 36000.5
  high        REAL    NOT NULL,   -- 36100.0
  low         REAL    NOT NULL,   -- 35900.0
  close       REAL    NOT NULL,   -- 36050.0
  volume      REAL    NOT NULL,   -- 123.456
  PRIMARY KEY (series_id, candle_time)
);
```

注意那个 `PRIMARY KEY (series_id, candle_time)`——它保证了同一个交易对的同一个时间点，只能有一条记录。

就像图书馆的书架编号：`(楼层, 架号)` 组合起来唯一确定一个位置。你不可能在同一个位置放两本不同的书。

---

## 7. 数据的完整旅程：从交易所到你的眼睛

现在把所有概念串起来，看一根 K 线的完整旅程：

```text
1. 币安交易所                    2. 后端接收
   BTC 在 1 分钟内                  parse_binance_kline_payload()
   开 36000, 高 36100,              检查 x=true（收盘了吗？）
   低 35900, 收 36050,              ↓ 是 → 包装成 CandleClosed
   量 123.456                       ↓ 否 → 只广播给前端看
        ↓                                    ↓
3. SQLite 存储                   4. 前端渲染
   INSERT INTO candles              toChartCandle() 转换格式
   (series_id, candle_time,         candleSeries.setData(candles)
    open, high, low, close,         → 屏幕上出现一根红/绿蜡烛
    volume)
```

一根蜡烛，从交易所的 JSON 消息，变成数据库里的一行记录，最终变成你屏幕上那根红绿柱子。

---

## 8. 为什么量化交易需要这些数据

你可能会问：知道了 K 线又怎样？

量化交易的核心思路是：**从历史价格中找规律，用规律预测未来，用预测指导交易。**

- 看到价格连续上涨（一连串绿色蜡烛）→ 可能是上升趋势 → 考虑买入
- 看到价格在一个区间反复震荡 → 可能是盘整 → 等待突破
- 看到成交量突然放大 → 可能有大资金进场 → 密切关注

但人眼看图容易犯错——你会被情绪影响，会看到不存在的"规律"。

所以量化交易用算法代替人眼。算法不会紧张，不会贪婪，不会恐惧。它只看数字，按规则执行。

这就是为什么系统需要 K 线数据：它是算法的"眼睛"。下一关我们会讲，算法怎么从这些蜡烛里"看出"趋势——那就是缠论的 pivot、pen、zhongshu。

---

## 9. 代码锚点

| 概念 | 文件 | 干什么的 |
| ---- | ---- | ---- |
| K 线数据结构 | `backend/app/schemas.py` | CandleClosed 定义 |
| 时间框架解析 | `backend/app/timeframe.py` | "1m" → 60 秒 |
| 衍生时间框架 | `backend/app/derived_timeframes.py` | 1m 拼成 5m/15m/1h |
| K 线存储 | `backend/app/store.py` | SQLite 表结构 |
| 交易对标识 | `backend/app/series_id.py` | SeriesId 定义 |
| 前端蜡烛转换 | `frontend/src/widgets/chart/candles.ts` | 后端格式 → 图表格式 |
| 前端图表渲染 | `frontend/src/widgets/chart/useLightweightChart.ts` | Lightweight Charts |
| 交易对选择器 | `frontend/src/parts/ChartPanel.tsx` | UI 交互 |
| WS 消息解析 | `frontend/src/widgets/chart/ws.ts` | 实时数据流 |

---

## 10. 过关自测

如果你能用自己的话回答这五个问题，第 4 关就过了：

1. 一根 K 线包含哪五个数字？用菜市场的比喻解释每个数字的含义。
2. 5 分钟线是怎么从 1 分钟线"拼"出来的？开盘价、收盘价、最高价分别取哪根？
3. `BTC/USDT` 这个交易对里，斜杠左边和右边分别是什么？
4. 为什么数据库用 `(series_id, candle_time)` 做主键？如果不加这个约束会怎样？
5. 为什么量化交易要用算法看 K 线，而不是用人眼看？
