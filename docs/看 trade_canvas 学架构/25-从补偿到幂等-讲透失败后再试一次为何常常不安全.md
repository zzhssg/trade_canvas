---
title: 第25关：从补偿到幂等，讲透"失败后再试一次"为何常常不安全
status: done
created: 2026-02-11
updated: 2026-02-11
---

# 第25关：从补偿到幂等，讲透"失败后再试一次"为何常常不安全

上一关你学了"错误怎么分层、怎么观测"。这一关解决"失败后怎么安全恢复"。

很多人刚做系统时，脑子里有一句"朴素真理"：

> 失败了就重试，再试一次总能好。

这句话在玩具程序里没问题，在真实链路里经常出事故。

因为真实系统不是一个动作，而是一条链：

- K线先写入 `candles`；
- 再驱动 `factor` 事件；
- 再驱动 `overlay` 指令；
- 最后还要对外发布。

就像你在 ATM 转账：扣款成功了，但到账失败了。这时候"再试一次"意味着什么？再扣一次款？

如果你"只会重试，不会幂等和补偿"，结局通常是：

- 数据重复；
- 局部成功、全局不一致；
- 你以为修复了，实际上把现场改得更难排障。

trade_canvas 在这件事上的设计很值得学：它不是迷信"重试"，而是把**幂等 + 补偿 + 可观测**当成一整套协议。

---

## 0. 先给一句总纲

"失败后再试一次"要安全，至少要同时满足三件事：

1. **幂等**：同一输入重复执行，不会把结果越写越乱；
2. **补偿**：中途失败时，能撤掉"本次新增影响"，不破坏旧数据；
3. **可观测**：失败时能说清楚"坏在哪步、补到哪步"。

少任何一个，重试都会变玄学。

---

## 1. 第一幕：为什么"再试一次"天然不安全

看 `IngestPipeline` 的主链路（`backend/app/pipelines/ingest_pipeline.py`）：

- `store.upsert_many_closed`
- `factor.ingest_closed`
- `overlay.ingest_closed`

这是典型"三段式写链路"。就像地铁换乘：第一站刷卡成功、第二站换乘失败——你直接重刷整条线，第一站会重复扣费。

危险点在于：

- 第 1 段成功、第 2 段失败；
- 或第 1、2 段成功、第 3 段失败。

这时你直接整批重试，会遇到两个经典问题：

1. **重复写问题**：同一事件是否会再落一次？
2. **脏状态问题**：第一次执行已写入部分状态，第二次从什么基线继续？

所以真正的问题不是"要不要重试"，而是"**重试时系统如何识别哪些东西已经算过、哪些是本次新增、哪些必须回滚**"。

---

## 2. 第二幕：先做"本次新增"识别，补偿才不会误伤

`IngestPipeline` 有个很关键的小动作：

- 写入前先查 `existing_closed_times_in_conn(...)`；
- 写入后计算 `new_candle_times = candle_times - existing_times`。

这一步非常像会计里的"本期新增流水"。

为什么重要？因为补偿动作 `_rollback_new_candles(...)` 只删 `new_candle_times`：

- 不会碰历史已经存在的 candle；
- 只撤销"这次尝试带来的新增行"。

这就是补偿的第一原则：

**补偿不是"全部回滚"，而是"精准撤销本次增量"。**

---

## 3. 第三幕：Candle 层幂等——可重复写，但不可无限膨胀

`CandleStore.upsert_many_closed_in_conn` 使用 `(series_id, candle_time)` 主键 + upsert：

- 同一个 `candle_time` 重复进来，不会新增第二行；
- 会按最新值覆盖 O/H/L/C/V。

这类幂等可以叫"键幂等"：

- **同键不扩容**（不爆行数）；
- **同键可更新**（允许修正值）。

它不是"什么都不做"，而是"重复输入不会把表写炸"。

---

## 4. 第四幕：Factor 层幂等——事件去重 + 头快照去噪

`FactorStore` 做了两层防重。

### 4.1 事件层

`factor_events` 有唯一约束：

- `UNIQUE (series_id, factor_name, event_key)`
- 写入时 `ON CONFLICT DO NOTHING`

含义很直接：同一业务事件（同 `event_key`）最多落一次。就像银行的发票号——同一张发票不管提交几次，只入账一次。

这也是为什么 `test_anchor_factor.py` 能断言：

- 重灌最后一根 candle 后，anchor `switches` 不增长。

### 4.2 头状态层

`insert_head_snapshot_in_conn` 对相同 `candle_time` 会先读最后一版：

- 如果 `head_json` 一样，直接复用原 `seq`；
- 只有 head 真变了，才 `seq + 1`。

这避免了"状态没变却刷版本号"的噪声。

`test_factor_head_store.py` 专门验证了这个行为：

- 同 head 重复写，`seq` 不增长；
- head 改变时，`seq` 才递增。

---

## 5. 第五幕：Overlay 层幂等——版本化写入，但先比较最新定义

`OverlayInstructionWriter.persist(...)` 在写每条指令前都会调用 `_is_latest_def_same(...)`：

- 若最新 `def_json` 与当前 payload 相同：跳过；
- 否则才插入新 `version_id`。

这让 overlay 既有"版本历史"，又不会"每次重算都长一版垃圾版本"。

`test_overlay_orchestrator_integration.py` 验证了关键点：

- 同一 `up_to_candle_time` 再 ingest 一次，`last_version_id` 不增加。

---

## 6. 第六幕：补偿不是事务万能药，它有边界

很多人会把补偿理解成"失败了就还原世界"。这是错的。

在 `IngestPipeline` 里，补偿是**有开关、有限度、分层级**的：

- `overlay_compensate_on_error`：overlay 失败时尝试 `reset_series`；
- `candle_compensate_on_error`：失败时删除本次新增 candle 行。

并且补偿结果会被显式记录进 `IngestPipelineError`：

- `compensated`
- `overlay_compensated`
- `candle_compensated_rows`
- `compensation_error`

这很关键：

**补偿是"尽力恢复到安全态"，不是"承诺恢复到失败前的每一个细节"。**

---

## 7. 第七幕：为什么补偿一定要配 runtime flag

这两个补偿能力默认不是硬开启，而是 runtime flag 控制：

- `TRADE_CANVAS_ENABLE_INGEST_COMPENSATE_OVERLAY_ERROR`
- `TRADE_CANVAS_ENABLE_INGEST_COMPENSATE_NEW_CANDLES`

在 `runtime_flags.py` 读取，在 `market_runtime_builder.py` 注入 `IngestPipeline`。

这背后的架构思想是：

- 新补偿策略先灰度，出问题可秒关；
- 回滚路径不靠"紧急改代码"，靠配置 kill-switch。

这就是"可回滚系统"的基本素养。

---

## 8. 第八幕：可观测性决定你能不能修复，而不是猜

如果失败只返回一句"ingest failed"，你根本不知道该做什么。

本项目把失败上下文结构化了：

- 错在哪一步（`step`）；
- 哪个 `series_id`；
- 是否补偿成功、补了几行。

`test_market_ingest_error_observability.py` 就在验证这个契约：

- HTTP 返回统一错误前缀；
- debug 事件里包含补偿细节字段。

也就是说，这里不只是"处理失败"，而是"把失败变成可诊断信号"。

---

## 9. 你可以直接迁移的工程方法论

把这关抽象成通用模板，就是下面 5 条：

1. **先定义幂等键**：没有稳定键，就没有安全重试；
2. **把补偿对象限定为本次增量**：避免误删历史；
3. **状态写入做去噪**：值没变就别制造新版本；
4. **补偿结果必须可观测**：别把"补偿失败"吞掉；
5. **高风险恢复策略必须有开关**：先灰度再默认。

你以后写订单系统、任务系统、事件总线，都是同一套思路。

---

## 10. 代码锚点（建议顺读）

- `backend/app/pipelines/ingest_pipeline.py`
- `backend/app/store.py`
- `backend/app/factor_store.py`
- `backend/app/overlay_ingest_writer.py`
- `backend/app/overlay_store.py`
- `backend/app/runtime_flags.py`
- `backend/app/market_runtime_builder.py`
- `backend/tests/test_ingest_pipeline.py`
- `backend/tests/test_anchor_factor.py`
- `backend/tests/test_factor_head_store.py`
- `backend/tests/test_overlay_orchestrator_integration.py`
- `backend/tests/test_market_ingest_error_observability.py`

---

## 11. 过关自测

1. 为什么"能重试"不等于"重试安全"？
2. `new_candle_times` 这一步在补偿里到底解决了什么风险？
3. `event_key + ON CONFLICT DO NOTHING` 为什么是事件幂等核心？
4. 为什么 overlay 需要"先比较最新 def 再决定写不写"？
5. 你现在项目里最危险的一条"失败后直接重试"链路是哪条？它缺的是幂等、补偿还是观测？

如果这 5 题你能讲清楚，你已经不只是"会写 retry"，而是开始具备"设计可恢复系统"的架构能力。
