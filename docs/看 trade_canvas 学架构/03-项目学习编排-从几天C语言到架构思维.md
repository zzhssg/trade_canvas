---
title: 第3关：项目学习编排——从几天 C 语言到架构思维
status: done
created: 2026-02-11
updated: 2026-02-11
---

# 第3关：项目学习编排——从几天 C 语言到架构思维

前两关你已经知道了：数据怎么从交易所流到你眼睛（第 1 关），代码里那些黑话是什么意思（第 2 关）。

现在问题来了：**这个项目几万行代码，我该从哪里开始看？按什么顺序看？看到什么程度算"学会了"？**

这就像你第一次去一座陌生城市。你不会把每条街都走一遍——你会先看地图，找到主干道，沿着主干道走一圈，然后再钻小巷子。

这篇就是你的"城市游览攻略"。

---

## 1. 先刻三条铁律进脑子

在看任何代码之前，先记住这三句话。它们是整个系统的宪法，后面所有设计都是为了守住它们：

**铁律一：closed 才算数。**
只有收盘的蜡烛才进计算。正在跳的蜡烛只能看，不能算。（第 1 关讲过，考试交卷了才能算分。）

**铁律二：先存后算，不边算边存。**
蜡烛先进仓库，再进流水线。流水线崩了，原料还在，修好了重新算。（面包店先放面粉进仓库，再开烤箱。）

**铁律三：写和读分开走。**
写数据（IngestPipeline）和读数据（各种 ReadService）是两条独立的路。写的时候不管谁在读，读的时候不管谁在写。（仓库的进货口和出货口分开，互不堵车。）

这三条不是"建议"，是"法律"。代码里到处都有测试在守护它们。违反了，测试会立刻报警。

---

## 2. 第一条路线：写侧闭环（数据怎么写进去）

你在城市里要走的第一条主干道，是"写侧"——数据从外面进来，经过加工，存进仓库的全过程。

沿着这条路走一遍，你就能理解"一个业务能力如何拆成管道、编排器、插件、存储"。

```text
第①站                第②站              第③站              第④站              第⑤站
币安 WS          IngestPipeline     FactorOrchestrator   FactorTickExecutor   FactorStore
(快递员送货)  →  (收发室登记入库)  →  (流水线主管规划)  →  (工人按顺序干活)  →  (半成品入库)
                                                                                  ↓
                                                              第⑥站          第⑦站
                                                         OverlayOrchestrator  OverlayStore
                                                         (渲染师画效果图)  →  (成品入库)
```

每一站对应一个文件，建议按顺序读：

| 站 | 文件 | 你会学到什么 |
| ---- | ---- | ---- |
| ① | `backend/app/ingest_binance_ws.py` | WebSocket 怎么接数据、forming/closed 怎么分流 |
| ② | `backend/app/pipelines/ingest_pipeline.py` | 四步曲怎么编排、出错怎么补偿回滚 |
| ③ | `backend/app/factor_orchestrator.py` | 窗口规划、增量恢复、fingerprint 检测 |
| ④ | `backend/app/factor_tick_executor.py` | DAG 拓扑排序、按顺序调用插件 |
| ⑤ | `backend/app/factor_store.py` | append-only 事件、head snapshot、幂等写入 |
| ⑥ | `backend/app/overlay_orchestrator.py` | 因子事件怎么翻译成图表指令 |

---

## 3. 第二条路线：读侧闭环（数据怎么读出来）

写侧是"货怎么进仓库"，读侧是"货怎么从仓库到顾客手里"。

前端打开页面，需要拿到 K 线、因子、覆盖层数据。它不是直接去翻仓库的箱子，而是通过一个"导购员"（ReadService）来拿。

```text
前端请求
   ↓
/api/factor/slices  →  FactorSlicesService  →  按 topo 顺序构建快照  →  返回 JSON
                       (导购员)                (先拿 pivot，再拿 pen，再拿 zhongshu)
```

为什么读的时候也要按 topo 顺序？

想象你去家具店买一套组合柜。导购员不能先给你柜门再给你柜体——你得先有柜体才能装柜门。读因子也一样：pen 的数据依赖 pivot 的数据，所以必须先读 pivot 再读 pen。

每一站对应的文件：

| 站 | 文件 | 你会学到什么 |
| ---- | ---- | ---- |
| ① | `backend/app/factor_slices_service.py` | 读模型怎么按 topo 顺序构建 |
| ② | `backend/app/factor_slice_plugins.py` | 每个因子的"切片"怎么输出 |
| ③ | `backend/app/overlay_package_service_v1.py` | 覆盖层数据怎么打包给前端 |

读完写侧和读侧两条路线，你就掌握了整个系统的主动脉和静脉。

---

## 4. 学习的四层进阶

不要试图一次看懂所有代码。按下面四层来，每层有明确的"过关标准"：

### 第一层：看懂输入输出（1-2 天）

只看 API 的请求和响应结构，不深入算法细节。

目标：能说清每个接口"吃什么、吐什么"。

就像你第一天去餐厅当服务员，先记住菜单上有什么菜、每道菜长什么样，不用知道厨师怎么炒的。

过关标准：能画出"前端发什么请求 → 后端返回什么数据"的流程图。

### 第二层：看懂状态机（3-5 天）

重点看 `FactorTickState`——每来一根蜡烛，因子的状态怎么变化。

目标：能画出状态变化图（不是类图，是"状态 A → 事件 X → 状态 B"的图）。

就像你开始学炒菜了：油温到了放葱花（状态变化），葱花变黄了放肉（又一次状态变化），肉变色了放酱油（再一次）。

过关标准：能解释"一根新蜡烛进来后，pivot/pen/zhongshu 各自的状态怎么变"。

### 第三层：看懂增量与重建（1 周）

重点看 bootstrap、rebuild、event 幂等这三个机制。

目标：能解释"为什么系统可以回放、可以补算、不会重复写"。

就像你开始理解厨房的管理制度了：为什么要先验货再入库（幂等）、为什么要留菜谱不留成品（可重建）、为什么每道菜都要拍照存档（事件日志）。

过关标准：能解释 fingerprint 怎么检测口径变化、rebuild 怎么触发、event_key 怎么防重复。

### 第四层：看懂演进策略（持续）

学会用 feature flag、manifest、回归测试做安全迭代。

目标：自己能设计"可回滚"的跨模块改动方案。

就像你从厨师升级成了餐厅经理：不只会做菜，还会设计新菜品的试吃流程（灰度发布）、处理食材供应商更换（依赖替换）、应对突发的食品安全事件（故障回滚）。

过关标准：能独立设计一个新因子插件的完整方案——从声明 depends_on 到写测试到灰度上线。

---

## 5. "术语-代码-测试"三点对拍法

只读代码会很虚。最稳的学习方法是三点对拍：

1. **术语**：先搞清楚这个概念叫什么。
2. **代码**：找到术语对应的真实实现。
3. **测试**：找到验证这个规则的测试用例。

举个例子，你想确认"拓扑顺序是稳定的"：

- 术语：DAG topo order（第 2 关讲过，选课系统排课表）
- 代码：`backend/app/factor_graph.py` 的 `_toposort()` 方法
- 测试：`backend/tests/test_factor_registry.py` 里的顺序断言

三个点都对上了，这个知识就从"我好像懂了"变成了"我确实懂了"。

就像学开车：教练说"先踩离合再挂挡"（术语），你在车上找到离合器和挡把（代码），然后实际操作一次确认车没熄火（测试）。三步都过了，你才真的会了。

---

## 6. 你最该偷师的 8 条工程方法论

读完这个项目，不只是学会了"这个项目怎么写的"，更重要的是学会了 8 条可以带走的通用方法论：

| 方法论 | 白话 | 在项目里的体现 |
| ---- | ---- | ---- |
| 单一权威输入 | 一个系统只认一个"真相来源" | closed candle 是唯一权威输入 |
| 插件化装配 | 声明依赖，让系统自动排序 | depends_on + topo_order |
| 事件驱动账本 | 只追加不修改，可回放 | FactorStore 的 append-only 事件 |
| 幂等写入 | 同一操作执行多次结果不变 | event_key + UNIQUE 约束 |
| 写读分离 | 写数据和读数据走不同的路 | IngestPipeline vs ReadService |
| fail-fast | 缺东西就立刻报错，不偷偷降级 | manifest 校验、fingerprint 检测 |
| feature flag | 不改代码就能开关功能 | TRADE_CANVAS_ENABLE_* |
| DoD 门禁 | 测试、构建、证据、文档同步交付 | pytest + build + e2e 三道门 |

这 8 条不是这个项目发明的，是整个软件工程行业几十年沉淀下来的。但在这个项目里，你能看到它们是怎么从理论变成代码的。

---

## 7. 推荐的第一轮必读文件

按这个顺序读，每个文件花 15-30 分钟，一周内可以走完写侧+读侧两条主线：

| 序号 | 文件 | 重点看什么 |
| ---- | ---- | ---- |
| 1 | `backend/app/pipelines/ingest_pipeline.py` | 四步曲的骨架 |
| 2 | `backend/app/factor_orchestrator.py` | 窗口规划和增量恢复 |
| 3 | `backend/app/factor_tick_executor.py` | DAG 调度和插件调用 |
| 4 | `backend/app/factor_graph.py` | 拓扑排序的实现 |
| 5 | `backend/app/factor_store.py` | 事件和快照的存储 |
| 6 | `backend/app/factor_manifest.py` | 插件注册和校验 |
| 7 | `backend/app/factor_slices_service.py` | 读模型的构建 |
| 8 | `backend/app/runtime_flags.py` | 控制面的设计 |

---

## 8. 过关自测

如果你能用自己的话回答这五个问题，第 3 关就过了：

1. 为什么 `forming` 不能进因子引擎？（用考试的比喻）
2. 为什么插件要声明 `depends_on`，不能靠手工排顺序？（用选课系统的比喻）
3. 为什么事件表要 append-only，还要配 head snapshot？（用游戏存档的比喻）
4. 为什么读侧也要按 topo 顺序构建 snapshot？（用组合柜的比喻）
5. "术语-代码-测试"三点对拍法的三个步骤分别验证什么？
