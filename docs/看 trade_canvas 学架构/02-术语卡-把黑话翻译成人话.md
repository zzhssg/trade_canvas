---
title: 第2关：术语卡——把黑话翻译成人话
status: done
created: 2026-02-11
updated: 2026-02-11
---

# 第2关：术语卡——把黑话翻译成人话

你打开代码，满屏都是 `series_id`、`forming`、`runtime_flags`、`event_key`、`head_snapshot`……

就像第一天去医院实习，主任查房说："这个病人 BP 偏高，BUN/Cr 比值异常，先上 NS 500ml iv drip。"

你听懂每个字了，但连起来完全不知道在说什么。

别慌。这篇就是你的"黑话-人话对照表"。读完这篇，再看代码，那些变量名就不再是天书了。

---

## 1. 数据身份证：谁是谁

### series_id——数据流的身份证号

你去银行开户，柜员会给你一个账号。这个账号唯一标识"你在这家银行的这个账户"。

`series_id` 就是数据流的账号。它告诉系统："这是币安现货市场的 BTC/USDT 的 1 分钟 K 线。"

```python
# backend/app/series_id.py
@dataclass(frozen=True)
class SeriesId:
    exchange: str      # "binance"——哪家交易所
    market: str        # "spot"——现货还是合约
    symbol: str        # "BTC/USDT"——什么币对
    timeframe: str     # "1m"——几分钟一根

    @property
    def raw(self) -> str:
        return f"{self.exchange}:{self.market}:{self.symbol}:{self.timeframe}"
        # 结果："binance:spot:BTC/USDT:1m"
```

就像身份证号 `110101199001011234` 编码了省市区+生日+序号，`series_id` 编码了交易所+市场+币对+周期。

### candle_id——单根蜡烛的指纹

`series_id` 标识一条数据流，`candle_id` 标识流里的某一根蜡烛。

```
candle_id = "binance:spot:BTC/USDT:1m:1707000000"
             ^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^
             series_id                 开盘时间戳
```

就像快递单号：前半段是发件网点编号，后半段是包裹序号。两个合在一起，全球唯一。

---

## 2. 蜡烛的两种状态：交卷了没有

### closed——交了卷的蜡烛

一根 K 线走完了它的时间周期（比如 1 分钟到了），开盘价、最高价、最低价、收盘价、成交量全部定格，不会再变。

这就是 `closed`——考试交卷了，成绩定了。

```python
# backend/app/ingest_binance_ws.py
is_final = bool(k.get("x"))  # 币安用 x=true 表示"这根K线收盘了"
return candle if is_final else None  # 没交卷？不收。
```

系统的铁律：**只有 closed 蜡烛才能进入因子计算、才能落库、才能作为策略依据。**

为什么？因为你不能拿一个还在变的数字去算趋势。就像老师不能拿还在答题的学生的试卷去算班级平均分。

### forming——还在答题的蜡烛

`forming` 是正在跳动的蜡烛。价格每秒都在变，收盘价只是"当前最新价"，随时会改。

它的用途只有一个：**让你在屏幕上看到蜡烛在实时跳动**。仅此而已。

```python
# backend/app/ingest_binance_ws.py
async def _broadcast_forming(self, series_id: str, candle: CandleClosed) -> None:
    # forming 蜡烛只广播给前端看，不进因子引擎，不落库
    await self._hub.publish_forming(series_id=series_id, candle=candle)
```

口令版：**forming 可看，不可算。closed 才算数。**

---

## 3. 计算流水线：谁先谁后

### factor——从原始价格里提炼出来的"体检指标"

你去体检，医生不会直接看你的血液，而是看血液检测报告上的指标——血糖、血压、白细胞。

K 线是血液，factor（因子）是指标。

这个系统用缠论，有四个因子：

| 因子 | 白话 | 比喻 |
|------|------|------|
| pivot | 价格的高低转折点 | 山脉的山顶和山谷 |
| pen | 相邻转折点连成的线段 | 连接山顶和山谷的山路 |
| zhongshu | 几笔重叠的震荡区域 | 山间的平原盆地 |
| anchor | 关键的买卖位置 | 平原边缘的路标 |

### depends_on——"我需要谁先算完"

每个因子都要声明自己依赖谁。就像做菜：炒菜依赖切菜，切菜依赖洗菜。你不能跳过洗菜直接炒。

```python
# backend/app/factor_processor_pivot.py
spec = FactorPluginSpec(
    factor_name="pivot",
    depends_on=(),          # 我不依赖任何人，我是起点
)

# backend/app/factor_processor_pen.py
spec = FactorPluginSpec(
    factor_name="pen",
    depends_on=("pivot",),  # 我需要 pivot 先算完
)
```

### DAG 和 topo_order——自动排出正确的计算顺序

`depends_on` 声明了依赖关系，系统会自动把它们排成一条线。这个排序算法叫"拓扑排序"（topological sort），排出来的结果叫 `topo_order`。

```python
# backend/app/factor_graph.py
class FactorGraph:
    @property
    def topo_order(self) -> tuple[str, ...]:
        return self._topo  # ("pivot", "pen", "zhongshu", "anchor")
```

就像大学选课系统：高等数学是线性代数的前置课，线性代数是概率论的前置课。系统自动帮你排出选课顺序，还会检测"循环依赖"——如果 A 依赖 B、B 又依赖 A，直接报错，不让你选。

### processor / plugin——流水线上的工人

`processor` 是干活的工人，每个工人负责一个因子的计算。`plugin` 是工人的工牌——上面写着"我叫什么、我依赖谁、我怎么干活"。

```python
# backend/app/factor_plugin_contract.py
class FactorTickPlugin(Protocol):
    @property
    def spec(self) -> FactorPluginSpec: ...        # 工牌：我是谁、我依赖谁

    def run_tick(self, *, state, runtime) -> None:  # 干活：每来一根蜡烛，算一次
        ...
```

为什么叫"插件"？因为它是可插拔的。今天你用缠论的四个因子，明天想加一个 MACD，只要写一个新 plugin、声明好 `depends_on`，插进去就行，不用改流水线的代码。

### manifest——工厂的花名册

`manifest` 记录了"这个工厂里有哪些工人"。系统启动时，它会检查：花名册上的计算工人（tick_plugins）和读取工人（slice_plugins）是不是一一对应。

```python
# backend/app/factor_manifest.py
@dataclass(frozen=True)
class FactorManifest:
    tick_plugins: tuple[FactorPlugin, ...]      # 负责计算的工人
    slice_plugins: tuple[FactorSlicePlugin, ...]  # 负责读取的工人
```

如果你加了一个新的计算工人但忘了加对应的读取工人，系统启动时就会报错。就像工厂规定：每个生产岗位必须配一个质检岗位，少一个都不行。

---

## 4. 存储三兄弟：仓库怎么分工

### CandleStore——面粉仓库

存原始 K 线。面粉送到了，先放仓库，再进流水线。万一流水线坏了，面粉还在，修好了重新加工。

### FactorStore——半成品仓库

存因子计算的结果。这个仓库有两种货架：

**事件货架（event）**：记录"发生了什么"。每条记录只追加、不修改，就像会计的账本——你可以加新的流水，但不能涂改旧的。

```python
# backend/app/factor_store.py
@dataclass(frozen=True)
class FactorEventWrite:
    series_id: str
    factor_name: str       # "pivot" / "pen" / ...
    candle_time: int       # 什么时候发生的
    kind: str              # "pivot.major" / "pen.confirmed" / ...
    event_key: str         # 唯一标识，防止重复记账
    payload: dict          # 具体内容
```

**快照货架（head snapshot）**：记录"现在是什么状态"。每算完一根蜡烛，拍一张照片存下来。下次恢复时，直接从最近的照片开始，不用从头算。

```python
# backend/app/factor_store.py
@dataclass(frozen=True)
class FactorHeadSnapshotRow:
    series_id: str
    factor_name: str
    candle_time: int
    head: dict          # 因子在这一刻的完整状态
```

就像游戏存档：事件是你的操作日志（"第 3 分钟杀了一个怪"），快照是你的存档点（"第 3 分钟时血量 80、等级 5、背包里有三把剑"）。读档时直接加载存档点，不用从第 1 分钟重新玩。

### OverlayStore——成品仓库

存图表绘制指令。"从 A 点到 B 点画一条红线"、"在 C 点放一个三角形标记"——这些就是覆盖层指令，前端拿到就能直接画。

### event_key——防止重复记账的流水号

每笔因子事件都有一个 `event_key`，数据库对它加了唯一约束。同一笔事件写两次，第二次会被自动忽略。

```python
# backend/app/factor_processor_pivot.py
key = f"major:{int(pivot.pivot_time)}:{str(pivot.direction)}:{int(window)}"
# 例："major:1707000000:up:50"
# 含义：在时间 1707000000，方向向上，窗口 50 的主枢纽点
```

这就是"幂等性"——同一个操作执行一次和执行一百次，结果一样。就像你往信箱里投同一封信，不管投几次，信箱里永远只有一封。

---

## 5. 系统管家：谁来组装这一切

### AppContainer——餐厅总经理

开业之前，总经理要做这些事：雇仓库管理员（CandleStore）、雇流水线主管（FactorOrchestrator）、雇渲染师（OverlayOrchestrator）、雇广播员（CandleHub）……然后把他们组装成一条流水线。

```python
# backend/app/container.py
@dataclass(frozen=True)
class AppContainer:
    store: CandleStore                    # 仓库管理员
    factor_store: FactorStore             # 半成品仓库
    factor_orchestrator: FactorOrchestrator  # 流水线主管
    overlay_orchestrator: OverlayOrchestrator  # 渲染师
    hub: CandleHub                        # 广播员
    ingest_pipeline: IngestPipeline       # 整条流水线
    runtime_flags: RuntimeFlags           # 运行参数表
    # ... 共 18 个核心组件
```

谁需要找谁合作，都通过总经理介绍——这叫"依赖注入"。好处是：换人的时候只改总经理的通讯录，不用改每个人的代码。

### IngestPipeline——流水线本身

总经理组装好的那条流水线。它的工作就是四步曲：存蜡烛 → 跑因子 → 跑覆盖层 → 通知前端。

如果中间某一步出错了，它还会尝试"补偿"——把刚存进去的蜡烛删掉、把覆盖层重置，尽量恢复到出错前的状态。就像工厂发现这批面包有问题，立刻下架召回。

### CandleHub——广播站

流水线跑完了，广播站负责通知所有正在收听的前端："BTC/USDT 1 分钟线又收了一根！"

```python
# backend/app/ws_hub.py
class CandleHub:
    async def publish_closed_batch(self, *, series_id, candles):
        # 给所有订阅了这个 series_id 的前端推送
        ...
    async def publish_forming(self, *, series_id, candle):
        # 推送正在跳动的蜡烛（仅展示用）
        ...
```

两种广播：`publish_closed_batch` 是正式新闻（交卷了的蜡烛），`publish_forming` 是实时快讯（还在跳的蜡烛）。

---

## 6. 控制面板：开关和旋钮

### feature flag——总闸刀

"要不要开启因子计算？""要不要开启覆盖层？""要不要开启回放功能？"

这些是非黑即白的开关，只有开和关两个状态。

```
TRADE_CANVAS_ENABLE_FACTOR_INGEST=true    # 因子计算：开
TRADE_CANVAS_ENABLE_OVERLAY_INGEST=false  # 覆盖层：关
TRADE_CANVAS_ENABLE_REPLAY_V1=true        # 回放：开
```

线上出了问题？不用改代码、不用重新部署，把对应的开关关掉就行。就像家里跳闸了，先把总闸拉下来止损，再慢慢查哪个电器短路了。

前端也有自己的开关，用 `VITE_ENABLE_*` 前缀：

```
VITE_ENABLE_REPLAY=true
VITE_ENABLE_BACKTEST=false
```

### runtime flags——仪表盘上的旋钮

如果 feature flag 是"开不开"，runtime flags 就是"开了以后按什么参数跑"。

```python
# backend/app/runtime_flags.py
@dataclass(frozen=True)
class RuntimeFlags:
    enable_factor_ingest: bool              # 开关：要不要算因子
    factor_pivot_window_major: int          # 旋钮：主枢纽窗口多大
    factor_pivot_window_minor: int          # 旋钮：次枢纽窗口多大
    factor_lookback_candles: int            # 旋钮：回看多少根蜡烛
    factor_state_rebuild_event_limit: int   # 旋钮：重建时最多处理多少事件
    # ... 共 30+ 个参数
```

就像空调：feature flag 决定"开不开空调"，runtime flags 决定"开了以后温度调几度、风速调多大、模式选制冷还是除湿"。

---

## 7. 生命周期：初始化和重建

### bootstrap——开业前的铺货

系统第一次启动，仓库是空的。`bootstrap` 负责从外部数据源（比如 Freqtrade 的历史数据文件）导入一批历史蜡烛，让系统有"存货"可以计算。

就像新开的超市，开业前要先从供应商那里进一批货摆上货架。

### rebuild——口径变了，全部重算

如果你改了因子的计算逻辑（比如调整了枢纽点的窗口大小），之前算出来的结果就不对了。系统会自动检测到这个变化，清空旧的因子数据，用新逻辑从头重算。

### fingerprint——口径变没变的验证码

系统怎么知道"口径变了"？靠 `fingerprint`（指纹）。

```python
# backend/app/factor_fingerprint.py
# 把所有影响计算结果的因素打包算一个哈希值
payload = {
    "series_id": series_id,
    "graph": list(graph.topo_order),      # 因子依赖图
    "settings": {...},                     # 参数配置
    "files": {                             # 关键代码文件的 SHA256
        "factor_orchestrator.py": "a1b2c3...",
        "pen.py": "d4e5f6...",
    },
}
fingerprint = hashlib.sha256(raw.encode()).hexdigest()
```

每次启动时，系统算一次当前指纹，和上次存的指纹比对。不一样？说明口径变了，触发 rebuild。

就像你每次去银行，柜员会核对你的身份证。身份证号没变，正常办业务；身份证号变了（不可能，但比喻一下），说明"你不是上次那个你"，需要重新开户。

---

## 8. 全家福：术语关系图

```text
                        ┌─────────────┐
                        │ AppContainer │ ← 总经理，组装所有人
                        └──────┬──────┘
                               │
              ┌────────────────┼────────────────┐
              v                v                v
        RuntimeFlags    IngestPipeline     CandleHub
        (旋钮参数)      (流水线四步曲)     (广播站)
                               │
              ┌────────┬───────┴───────┬────────┐
              v        v               v        v
         CandleStore  FactorOrch.  OverlayOrch.  publish
         (面粉仓库)   (因子编排)    (覆盖层编排)   (通知前端)
                          │
                    ┌─────┴─────┐
                    v           v
              FactorGraph   Plugins
              (DAG排序)    (pivot/pen/...)
                               │
                          ┌────┴────┐
                          v         v
                     event_key  head_snapshot
                     (防重复)    (快速恢复)
```

---

## 9. 速查表

| 术语 | 一句话解释 | 比喻 |
| ---- | ---- | ---- |
| series_id | 数据流的唯一标识 | 银行账号 |
| candle_id | 单根蜡烛的唯一标识 | 快递单号 |
| closed | 收盘定格的蜡烛 | 交了卷的试卷 |
| forming | 还在跳动的蜡烛 | 还在答题的试卷 |
| factor | 从价格提炼的分析指标 | 体检报告指标 |
| depends_on | 因子间的依赖声明 | 选课前置条件 |
| topo_order | 自动排出的计算顺序 | 选课系统排的课表 |
| plugin | 可插拔的计算单元 | 流水线上的工人 |
| manifest | 插件花名册 | 工厂员工名单 |
| event_key | 防重复的唯一流水号 | 会计账本的凭证号 |
| head snapshot | 因子状态的存档点 | 游戏存档 |
| overlay | 图表绘制指令 | 建筑效果图 |
| AppContainer | 依赖注入容器 | 餐厅总经理 |
| IngestPipeline | 写链路四步曲 | 食品加工流水线 |
| CandleHub | WS 广播站 | 电台广播 |
| feature flag | 功能开关 | 家里的总闸刀 |
| runtime flags | 运行参数集合 | 空调的温度和风速 |
| bootstrap | 首次导入历史数据 | 新超市开业铺货 |
| rebuild | 口径变化后全量重算 | 推倒重来 |
| fingerprint | 口径变化检测码 | 银行核对身份证 |

---

## 10. 代码锚点

| 术语 | 文件 |
| ---- | ---- |
| series_id | `backend/app/series_id.py` |
| closed/forming | `backend/app/ingest_binance_ws.py` |
| factor/plugin | `backend/app/factor_plugin_contract.py` |
| depends_on/DAG | `backend/app/factor_graph.py` |
| manifest | `backend/app/factor_manifest.py` |
| event_key/snapshot | `backend/app/factor_store.py` |
| overlay | `backend/app/overlay_orchestrator.py` |
| AppContainer | `backend/app/container.py` |
| IngestPipeline | `backend/app/pipelines/ingest_pipeline.py` |
| CandleHub | `backend/app/ws_hub.py` |
| runtime flags | `backend/app/runtime_flags.py` |
| fingerprint | `backend/app/factor_fingerprint.py` |
| bootstrap | `backend/app/history_bootstrapper.py` |

---

## 11. 过关自测

如果你能用自己的话回答这五个问题，第 2 关就过了：

1. `forming` 和 `closed` 的区别是什么？为什么 forming 不能进因子计算？
2. `event_key` 解决什么问题？如果没有它会怎样？
3. `head snapshot` 和 `event` 的关系是什么？用游戏存档的比喻解释。
4. `feature flag` 和 `runtime flags` 有什么区别？用空调的比喻解释。
5. `fingerprint` 怎么知道"口径变了"？变了之后系统会做什么？
