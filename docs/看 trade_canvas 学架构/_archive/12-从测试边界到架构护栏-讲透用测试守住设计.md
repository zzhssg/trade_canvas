---
title: 第12关：从测试边界到架构护栏，讲透“用测试守住设计”
status: done
created: 2026-02-11
updated: 2026-02-11
---

# 第12关：从测试边界到架构护栏，讲透“用测试守住设计”

很多人把测试理解成“防 bug 的保险”。

这句话只说对了一半。

在 trade_canvas 这种系统里，测试更重要的作用是：

**把架构意图变成可执行约束，防止系统在迭代中悄悄变形。**

你可以把它理解成：

- 文档告诉你“应该怎么做”；
- 测试保证你“不能乱做”。

---

## 0. 先给一句总纲

“用测试守住设计”不是多写几个 assert，而是四层护栏一起上：

1. **边界护栏**：禁止越权访问与层间耦合。
2. **语义护栏**：关键不变量必须可验证。
3. **链路护栏**：主用户故事端到端可回放。
4. **演进护栏**：开关/回滚/失效语义有回归保护。

这四层少一层，系统都可能“看起来没坏，实际上在腐烂”。

---

## 1. 第一层：边界护栏（先防架构塌陷）

`backend/tests/test_app_state_boundary.py` 很像“架构警察”，它不是测功能，而是测边界。

它明文禁止一批高风险坏味道：

- route / ws handler 直接读 `request.app.state` 或 `ws.app.state`；
- `main.py` 往 `app.state` 塞多个对象（只允许 `container`）；
- route 依赖参数写成可选 `= None`；
- service/read-model 直接读环境变量；
- service 直接抛 `HTTPException`（应该抛 `ServiceError`，由 route 映射 HTTP）；
- service 层自己写 SQL（replay/overlay 的 SQL 读取应在 `*reader_v1`）。

这类测试的价值是：

**即使功能还跑得通，只要边界破了，CI 也会先红。**

这就是“先保形状，再谈功能”。

---

## 2. 第二层：语义护栏（关键不变量要可断言）

### 写链路失败语义

`backend/tests/test_ingest_pipeline.py` 守住了几个关键点：

- 失败必须带上下文（`IngestPipelineError.step/series_id`）；
- 补偿要可控（`overlay_compensate_on_error` / `candle_compensate_on_error`）；
- 补偿结果可观测（`compensated`、`overlay_compensated`、`candle_compensated_rows`）。

这保证了“失败不是黑箱异常”，而是可治理状态。

### 时序语义

`backend/tests/test_ws_hub_delivery.py` + `backend/tests/test_e2e_user_story_market_sync.py` 守住：

- gap 是否该发、何时该发；
- catchup/live 竞态下不重复发送；
- gap backfill 能否先补后发。

这让“时序一致性”从口号变成可回归契约。

---

## 3. 第三层：链路护栏（用用户故事串起来）

看 `test_e2e_user_story_market_sync.py` 的注释就很直白：

1. HTTP ingest closed candle；
2. HTTP incremental read；
3. WS subscribe 收 catchup + live；
4. 缺口时发 gap。

这就是一条完整主链路故事。

意义在于：

- 单测都绿，不代表链路能跑通；
- E2E 把“模块正确”提升为“系统正确”。

你会发现它还覆盖了 race 场景（延迟 `get_closed`）和开关场景（启用 gap backfill）。

这叫“在最容易翻车的地方加门禁”。

---

## 4. 第四层：演进护栏（开关与回滚必须可测）

### Flags 不是配置细节，而是演进协议

`backend/tests/test_runtime_flags.py`、`test_backend_architecture_flags.py` 这组测试本质在验证：

- 默认值是否合理；
- env override 是否生效；
- 开关关闭时系统是否显式降级，而不是半开半关；
- runtime 里的 pipeline/hub 是否保持单实例一致性。

### replay/overlay 的失效语义

`test_replay_prepare_service.py`、`test_replay_package_v1.py`、`test_replay_overlay_package_api.py` 在守：

- `prepare -> read_only -> build -> status -> window` 的状态机是否稳定；
- coverage 不足、ledger out_of_sync、cache 命中这三类状态是否区分清楚；
- 回放包构建后是否能按窗口读取。

这让“功能上线后怎么渐进放量、怎么出问题就回滚”变成可验证流程。

---

## 5. 一条你可以直接复用的测试编排法（很实用）

给你一个通用模板，任何中大型项目都能套：

1. **边界测试先写**（禁止越层、禁止隐式依赖）。  
2. **语义测试补齐**（不变量、错误语义、时序语义）。  
3. **E2E 选一条主故事打穿**（别一上来全链路全覆盖）。  
4. **开关与回滚单测化**（默认值、override、关闭语义）。

顺序别反。

很多团队失败在“先写大量功能单测，最后才发现架构已经耦合成一锅粥”。

---

## 6. 新手最容易踩的三个坑

### 坑 1：把测试当“结果检查器”，不是“设计约束器”

只测输出，不测边界，最后代码能跑但不可维护。

### 坑 2：E2E 全写 happy path

没测竞态、没测容量拒绝、没测开关降级，线上一抖就全露馅。

### 坑 3：开关不进测试

功能开关看起来可回滚，实际一关就 500，因为从没测过关闭路径。

---

## 7. 为什么这套方法能让你“像 10 年架构师一样思考”

因为它训练的是这几个核心能力：

- 先找系统不变量，而不是先写功能；
- 把“抽象设计”翻译成“可执行断言”；
- 让每次改动都在护栏里演进，而不是靠运气不出事故。

架构师和初级工程师的最大差异，不是会不会写复杂代码，
而是能不能设计一套**即使团队换人也不会崩的约束系统**。

测试就是这套约束系统最便宜、最稳定的载体。

---

## 8. 代码锚点（建议按层阅读）

- 边界护栏：`backend/tests/test_app_state_boundary.py`
- 演进开关：`backend/tests/test_runtime_flags.py`
- 架构装配：`backend/tests/test_backend_architecture_flags.py`
- 写链路语义：`backend/tests/test_ingest_pipeline.py`
- WS 时序：`backend/tests/test_ws_hub_delivery.py`
- 主链路 E2E：`backend/tests/test_e2e_user_story_market_sync.py`
- replay 流程：`backend/tests/test_replay_prepare_service.py`
- replay 包：`backend/tests/test_replay_package_v1.py`
- overlay 包：`backend/tests/test_replay_overlay_package_api.py`

---

## 9. 过关自测

1. 为什么 `test_app_state_boundary.py` 这类测试比很多功能单测更“架构级”？  
2. 你如何区分“语义测试”和“链路测试”？  
3. 如果只保留一条 E2E 用户故事，你会选哪条，为什么？  
4. 为什么开关关闭路径必须进测试，而不只是测开启路径？  
5. 你现在这个项目，最该补的一条“边界护栏测试”是什么？

如果这 5 题你能回答清楚，你已经从“会写测试”进阶到“会用测试守住架构”。
