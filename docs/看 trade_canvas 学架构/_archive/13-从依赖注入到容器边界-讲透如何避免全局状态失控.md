---
title: 第13关：从依赖注入到容器边界，讲透如何避免全局状态失控
status: done
created: 2026-02-11
updated: 2026-02-11
---

# 第13关：从依赖注入到容器边界，讲透如何避免全局状态失控

你写后端写到一定阶段，几乎一定会踩同一个坑：

一开始图快，把对象到处塞成“全局可拿”；
后来模块一多，谁改了谁、谁依赖谁，没人说得清。

最后系统还能跑，但团队会进入一种状态：

- 改一个点，担心影响十个点；
- 测试看似都在，定位却越来越慢；
- 新人上手第一句是“这个对象到底从哪来的？”

trade_canvas 在这件事上的核心解法是：

**把“拿依赖”这件事集中到容器边界，只允许一条受控路径。**

---

## 0. 先给一句总纲

依赖注入（DI）真正要解决的，不是“写法优雅”，而是三件硬问题：

1. **依赖可追踪**：对象从哪里来，一眼能查。  
2. **生命周期可控**：谁是单例、谁按请求取，边界明确。  
3. **替换成本可控**：开关/mock/重构时，不用全局搜字符串。

这就是“架构可演进”的基础设施。

---

## 1. 先识别危险源：全局状态为什么会失控

全局状态的问题不是“不能用”，而是“没有边界”。

常见失控模式：

- 任意 route 直接 `request.app.state.xxx` 拿对象；
- service 内部直接读 `os.environ` 决策；
- route 直接 new 底层组件，绕开统一装配；
- service 直接抛 HTTP 异常，把传输层语义污染到领域层。

这些做法短期快，长期会把系统变成“隐式耦合网”。

trade_canvas 的做法很明确：

**可以有共享状态，但共享入口必须唯一且受约束。**

---

## 2. 组合根（Composition Root）：只在一个地方装配全世界

核心装配点是：

- `backend/app/main.py:create_app()`
- `backend/app/container.py:build_app_container()`

流程是：

1. `create_app()` 加载 settings；
2. 调 `build_app_container()` 一次性构建对象图；
3. `app.state` 只挂 `container`；
4. routes/ws handlers 注册时只拿容器里的已装配对象。

这就是标准组合根模式：

- **对象创建集中**（container）；
- **对象使用分散**（routes/services）；
- 中间靠依赖注入连接，而不是靠“全局随手拿”。

一句白话：

“厨房只在后厨做菜，前厅只点单，不许现场生火。”

---

## 3. 容器不是大杂烩，它是“受类型约束的对象图”

`AppContainer` 是 dataclass，字段显式列出系统核心组件：

- stores（`CandleStore/FactorStore/OverlayStore`）
- orchestrators（factor/overlay）
- read services（factor/draw/world/repair）
- replay services（prepare/package/overlay package）
- market runtime（hub/supervisor/ingest pipeline）
- flags/settings/debug hub/backtest/worktree manager

这有两个工程价值：

1. 新人看容器字段就能知道系统主件清单。  
2. 任何新增核心能力，都要显式进入容器，避免“野生单例”。

容器本身就像一份“活的架构目录”。

---

## 4. DI 网关：`dependencies.py` 把入口收成一条窄门

`backend/app/dependencies.py` 做了很关键的收口：

- `get_app_container(request)`：从 `app.state.container` 取容器；
- `get_xxx(...)`：从容器分发具体服务；
- `Annotated[..., Depends(...)]`：给 route 使用。

这意味着 route 层拿依赖只有两种合法路径：

1. 参数注入（推荐）；
2. ws handler 由 `main.py` 显式传参。

没有第三条“偷偷摸摸拿全局”的路。

这就是“窄门策略”：入口少，治理才可能稳定。

---

## 5. 为什么要强制“app.state 只放 container”

`test_app_state_boundary.py` 明确断言：

- `main.py` 对 `app.state` 的赋值只能是 `container`。

这条看似苛刻，其实是防止演进期最常见腐化：

- 今天加 `app.state.store`，明天加 `app.state.runtime`，
- 三个月后没人知道谁该从哪拿，DI 形同虚设。

所以 trade_canvas 用测试把这条规则写死：

**全局状态允许存在，但只允许以容器对象形式存在。**

---

## 6. 分层语义：service 不讲 HTTP，route 不讲底层存储

同一套边界测试还守了两件更深的事：

1. service 不直接抛 `HTTPException`（应抛 `ServiceError`）。  
2. replay/overlay service 不直接写 SQL（读取下沉到 `*reader_v1`）。

这本质上是在保护两条分层边界：

- 传输层（HTTP）与业务层（service）解耦；
- 编排层（service）与数据访问层（reader）解耦。

你能得到的好处很实在：

- 同一 service 能复用于 HTTP、CLI、任务线程；
- SQL schema 变更时，影响面更可控；
- 单测可以按层定位，而不是全链路混在一起。

---

## 7. runtime flags 注入：禁止 service 直接读环境变量

另一个关键约束是：

- flags 在容器构建阶段统一解析（`load_feature_flags` / `load_runtime_flags`）；
- service/runtime 只接收注入后的值，不再自行读 env。

边界测试也在抓这个：

- runtime path 模块不得直接 `os.environ` / `resolve_env_*`。

这解决了一个隐形大坑：

**同一个测试进程里，环境变量被某个模块“即时读取”导致行为漂移。**

统一在组合根注入后，行为就变成可预期、可回放。

---

## 8. 子系统也要有自己的容器边界

`build_market_runtime()` 其实就是“子容器装配器”：

- 组装 market 的 reader/backfill/ws_delivery/orchestrator/hub/supervisor；
- 再把这套 runtime 交给主容器。

这相当于把大系统拆成“主容器 + 子容器”：

- 主容器管全局组装；
- 子容器管域内一致性（market 自己的一套对象关系）。

这样拆的价值：

- 你改 market 内部装配，不会波及 replay/backtest/read-model 全域；
- 并行开发时，目录边界和依赖边界更一致。

---

## 9. 生命周期语义：哪些是单例，哪些是流程对象

从 `create_app()` 的生命周期可以读出语义：

- 容器与核心服务：应用生命周期单例；
- ws 连接相关状态：hub/supervisor 内部按连接/订阅动态管理；
- startup/shutdown 动作（startup sync、whitelist ingest、reaper）：挂在 lifespan。

这就是“对象创建位置决定生命周期边界”。

你以后做性能排障时，先问一句：

“这个对象是 per-app 还是 per-request？”

很多内存泄漏和并发 bug 就从这句开始被抓出来。

---

## 10. 给你一个可直接套用的 DI 设计清单

每加一个新能力，按这 6 步走：

1. 先定义 service 协议与错误语义（不碰 HTTP）。  
2. 把构造参数放进容器构建函数。  
3. 在 `dependencies.py` 暴露 `get_xxx` 函数。  
4. route 只通过 Dep 类型拿服务。  
5. 补一条边界测试（防止后续越层）。  
6. 补一条主链路测试（证明接线正确）。

这 6 步会显著降低“新功能引入隐式耦合”的概率。

---

## 11. 代码锚点（建议按这个顺序读）

- `backend/app/main.py`
- `backend/app/container.py`
- `backend/app/dependencies.py`
- `backend/app/market_runtime_builder.py`
- `backend/tests/test_app_state_boundary.py`
- `backend/tests/test_backend_architecture_flags.py`
- `backend/tests/test_runtime_flags.py`

---

## 12. 过关自测

1. 为什么 `app.state` 只放 `container` 反而更灵活？  
2. `dependencies.py` 在架构上扮演的角色到底是什么？  
3. 为什么 service 抛 `ServiceError` 比直接抛 `HTTPException` 更稳？  
4. runtime flags 为什么必须在组合根解析，而不是在 service 内即时读取？  
5. 如果你要新增一个 `TradeRiskService`，它应该接入哪几层，按什么顺序？

如果这 5 题你能顺畅回答，你已经不只是“会用 DI”，而是开始具备“设计可演进容器边界”的能力了。
