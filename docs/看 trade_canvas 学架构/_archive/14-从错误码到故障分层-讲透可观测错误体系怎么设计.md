---
title: 第14关：从错误码到故障分层，讲透可观测错误体系怎么设计
status: done
created: 2026-02-11
updated: 2026-02-11
---

# 第14关：从错误码到故障分层，讲透可观测错误体系怎么设计

你做系统久了会发现一个残酷现实：

线上真正难的，不是“会不会报错”，而是**报错时你能不能 5 分钟内定位层级和责任边界**。

如果错误体系设计不好，常见现场是：

- 前端只看到 `HTTP 500`；
- 后端日志一堆 stacktrace，但不知道是输入错、状态错、还是系统错；
- 同一类故障在不同接口上长得完全不一样。

trade_canvas 这套错误体系的核心价值，就是把“异常”变成“可分层诊断信号”。

---

## 0. 先给一句总纲

一套可观测错误体系，至少要同时回答 4 个问题：

1. **错在哪一层**（输入 / 业务状态 / 资源容量 / 内部故障）？  
2. **谁该处理**（调用方重试、用户修正、运维介入、开发修复）？  
3. **怎么观测**（HTTP 返回、WS 消息、debug 事件、测试断言）？  
4. **是否可回滚**（开关关闭、降级路径、补偿路径）？

trade_canvas 的做法不是“一个万能错误对象”，而是**分通道、分层级、分责任**。

---

## 1. 先分层：不是所有错误都叫“失败”

在本项目里，至少有四类“非成功状态”：

1. **输入层错误**：请求格式或参数不合法（例如 WS 消息 envelope/type 不合法）。  
2. **状态层错误**：系统状态暂时不满足不变量（最典型是 `ledger_out_of_sync:*`）。  
3. **能力层错误**：功能没开、容量满、资源不可用（`not_found` gate、`capacity`）。  
4. **内部层错误**：代码/依赖执行失败（`ingest_pipeline_failed:*` 等）。

这套分层最关键的收益是：

**调用方可以根据层级决定动作，而不是看到 error 就盲重试。**

---

## 2. HTTP 通道：ServiceError 做内部分型，Route 统一映射

核心机制在：

- `backend/app/service_errors.py`

`ServiceError` 有三件事：

- `status_code`
- `detail`
- `code`（内部语义码）

然后 route 层统一：

- `except ServiceError as exc: raise to_http_exception(exc)`

这个模式在 `draw/world/replay/market/backtest/repair` 路由都一致。

### 一个重要细节（很多人会忽略）

`to_http_exception()` 当前只把 `status_code + detail` 往外返回，**不会把 `code` 回传给客户端**。  
也就是说：

- `code` 主要服务后端内部分型/日志/测试；
- 外部调用方目前主要依赖 `status_code + detail`。

这是一个明确权衡：客户端负担小，但内部仍保留强分型。

---

## 3. WS 通道：错误直接协议化（code + message）

WS 这条链路和 HTTP 不同，它直接把错误编码进消息协议：

- `backend/app/ws_protocol.py`
- `backend/app/market_data/ws_services.py`

典型 payload：

```json
{"type":"error","code":"bad_request","message":"invalid message envelope"}
```

以及容量错误：

```json
{"type":"error","code":"capacity","message":"ondemand_ingest_capacity","series_id":"..."}
```

这让前端 WS 客户端可以做稳定分支处理，而不是靠字符串模糊匹配。

一句话：

**HTTP 偏“状态码 + detail”，WS 偏“协议内结构化错误码”。**

---

## 4. 最关键的状态错误：`ledger_out_of_sync` 家族

你会在多个读服务里看到同一个主题：

- `factor_read.ledger_out_of_sync`
- `draw_read.ledger_out_of_sync.overlay`
- `world_read.ledger_out_of_sync`
- `replay_prepare.ledger_out_of_sync.*`
- `read_repair.ledger_out_of_sync.*`

它们本质都在表达同一个事实：

**输入时间点可对齐，但读模型尚未追平到该时间点。**

这类错误通常是 409，不是 500。语义是“状态冲突/暂不可读”，不是“系统崩了”。

这就是优秀错误体系的标志：

- 不把“可恢复状态问题”误标成“服务器内部错误”。

---

## 5. 能力错误：开关关闭与容量上限必须显式

两个非常典型的能力错误：

1. **功能开关关闭 -> 404 not_found**  
   - 例如 repair API、部分 health/debug/replay 路径，在 flag 关闭时直接 404。

2. **资源容量不足 -> capacity**  
   - WS ondemand ingest 超过上限，返回 `code=capacity`，且不偷偷发该 series 数据。

这两个设计原则非常工程化：

- 关掉就“彻底不可见”，不是半可用；
- 满载就“明确拒绝”，不是拖死系统。

---

## 6. 不是所有“非 done”都要抛异常：状态机优先

replay 链路里有个很值得学的点：

- `read_only` 会返回 `done/build_required/coverage_missing/out_of_sync`。

这几个状态里，只有部分是“异常”；其余是“下一步动作提示”。

这是一种高级错误设计范式：

**把流程分支建模为状态，而不是都塞进异常。**

你得到的是：

- 更稳定的前端状态机；
- 更少 try/except 杂音；
- 更清晰的用户引导（先 coverage，再 build）。

---

## 7. 可观测性闭环：debug_hub 把“错误上下文”补齐

错误若只剩一行 detail，排障效率依然低。

trade_canvas 通过 `DebugHub` 加了一条观测侧链：

- `ts/source/pipe/event/series_id/level/message/data`

尤其在 `MarketIngestService` 里，`IngestPipelineError` 会被展开成结构化 debug data：

- `step`
- `series_id`
- `compensated`
- `overlay_compensated`
- `candle_compensated_rows`
- `compensation_error`

这让你看到的不再是“失败了”，而是“失败在哪一步，补偿做到哪一步”。

---

## 8. 测试就是错误体系契约（不是可选项）

这套错误设计不是靠约定，而是靠测试钉死：

- `test_market_ws.py`：bad_request/capacity 错误形态；
- `test_market_ingest_error_observability.py`：500 映射 + debug 补偿字段；
- `test_read_repair_api.py`：开关关闭 404、repair 后恢复；
- `test_factor_read_service.py`：strict 模式下 409 ledger_out_of_sync；
- `test_replay_prepare_service.py`：404 no_data / 409 out_of_sync；
- `test_app_state_boundary.py`：service 必须抛 `ServiceError`，route 负责 HTTP 映射。

一句话：

**没有回归测试的错误体系，迟早会被“临时修复”破坏。**

---

## 9. 这套体系的通用软件工程方法论

- **错误先分层，再编码**：输入错、状态错、容量错、内部错。  
- **通道分责**：HTTP/WS/debug 各自承担不同粒度信息。  
- **状态优先于异常**：可预期流程分支尽量状态机化。  
- **错误要可观测**：至少带 step/context，别只给一行 message。  
- **错误契约测试化**：错误形态和成功形态一样都要回归保护。

你以后做支付、任务调度、消息消费，同样适用。

---

## 10. 代码锚点（建议顺读）

- `backend/app/service_errors.py`
- `backend/app/ws_protocol.py`
- `backend/app/market_data/ws_services.py`
- `backend/app/market_ws_routes.py`
- `backend/app/market_ingest_service.py`
- `backend/app/read_models/draw_read_service.py`
- `backend/app/read_models/world_read_service.py`
- `backend/app/read_models/repair_service.py`
- `backend/app/replay_prepare_service.py`
- `backend/tests/test_market_ws.py`
- `backend/tests/test_market_ingest_error_observability.py`
- `backend/tests/test_read_repair_api.py`
- `backend/tests/test_factor_read_service.py`
- `backend/tests/test_replay_prepare_service.py`

---

## 11. 过关自测

1. 为什么 `ledger_out_of_sync` 应该多数是 409，而不是 500？  
2. HTTP 和 WS 的错误载体为什么不必完全一致？  
3. `ServiceError.code` 不直接对外返回，有什么利弊？  
4. 为什么 replay 的 `coverage_missing` 更适合做状态而不是异常？  
5. 你现在项目里最该补的一条“错误契约测试”是哪条？

如果这 5 题你能讲清楚，你已经从“会抛异常”进阶到“会设计故障分层系统”。
