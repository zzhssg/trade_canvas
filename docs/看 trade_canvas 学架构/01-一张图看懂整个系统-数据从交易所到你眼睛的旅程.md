---
title: 第1关：一张图看懂整个系统——数据从交易所到你眼睛的旅程
status: done
created: 2026-02-11
updated: 2026-02-11
---

# 第1关：一张图看懂整个系统——数据从交易所到你眼睛的旅程

你现在面前有一个量化交易工作台的完整代码。
几万行，几十个文件，打开就头晕。

别慌。

今天我们不看代码。我们只回答一个问题：

**一根 K 线，从币安交易所出发，经过了哪些站，最终变成你屏幕上那根红绿柱子？**

把这条路走通，整个系统你就懂了一半。

---

## 0. 先给你一张地铁图

把整个系统想象成一条地铁线路。数据就是乘客，从始发站上车，经过每一站处理，最终到达终点站——你的眼睛。

```
币安交易所                                              你的屏幕
   |                                                      |
   v                                                      v
[1号站]        [2号站]       [3号站]        [4号站]      [5号站]
WebSocket  →  K线仓库  →  因子流水线  →  覆盖层工厂  →  前端图表
(接数据)      (存原料)     (算信号)      (画标记)      (看结果)
```

就这五站。下面我们一站一站走。

---

## 1. 第一站：WebSocket 接收——快递员上门

币安交易所每时每刻都在产生交易数据。它通过 WebSocket（你可以理解为一根永远不挂的电话线）把数据推给你。

推过来的数据长这样：

```json
{
  "k": {
    "t": 1700000000000,   // 这根K线的开始时间（毫秒）
    "o": "36000.5",       // 开盘价
    "h": "36100.0",       // 最高价
    "l": "35900.0",       // 最低价
    "c": "36050.0",       // 收盘价
    "v": "123.456",       // 成交量
    "x": true             // 关键！这根K线"关门"了没有？
  }
}
```

注意那个 `"x": true`。这是整个系统最重要的一个布尔值。

`x = true` 意味着这根 K 线已经**收盘**了，盖棺定论了，数字不会再变。
`x = false` 意味着这根 K 线还在**跳动**，价格随时在变。

这就像考试：
- `x = false`：你还在答题，答案随时会改。
- `x = true`：交卷了，成绩定了。

系统的铁律：**只有交了卷的 K 线（closed），才有资格进入后面的计算。还在答题的（forming），只能在屏幕上实时显示，不参与任何分析。**

为什么？因为你不能拿一个还在变的数字去算趋势。就像你不能拿一个还没考完的学生的成绩去算班级排名。

代码在哪：`backend/app/ingest_binance_ws.py` 的 `parse_binance_kline_payload` 函数。它做的事很简单——检查 `x` 是不是 `true`，是的话把 JSON 翻译成内部格式，不是的话丢掉（不进计算链路）。

```python
is_final = bool(k.get("x"))
candle = CandleClosed(
    candle_time=int(open_ms_int // 1000),  # 毫秒转秒
    open=float(o), high=float(h),
    low=float(l),  close=float(c),
    volume=float(v),
)
return candle if is_final else None  # 没交卷？不收。
```

---

## 2. 第二站：K 线仓库——把原料存好

K 线到了系统内部，第一件事不是分析，是**存起来**。

为什么要先存？

想象你开了一家面包店。面粉送到了，你是先做面包还是先放进仓库？
当然是先放仓库。因为：
- 万一烤箱坏了（因子计算出错），面粉还在，修好了可以重新烤。
- 你想知道上周用了多少面粉（历史查询），仓库里有记录。
- 新来的学徒想练手（回放功能），仓库里有原料给他练。

代码里，这个仓库叫 `CandleStore`，用的是 SQLite 数据库。存法很简单：

```python
# 先存 K 线（原料入库）
self._store.upsert_many_closed_in_conn(conn, series_id, candles)
conn.commit()
```

`upsert` 这个词是 `update + insert` 的合体——有就更新，没有就插入。这保证了同一根 K 线存两次不会出问题（幂等性，后面会专门讲）。

---

## 3. 第三站：因子流水线——把面粉变成面包

原料存好了，现在要加工。

"因子"是量化交易的术语，你可以理解为**从原始价格数据中提炼出来的分析信号**。就像医生不会直接看你的血液，而是看血液检测报告上的各项指标——血糖、血压、白细胞。K 线是血液，因子是指标。

这个系统用的是缠论（一种中国本土的技术分析方法），它的因子链是这样的：

```
K线（原始价格）
  ↓
Pivot（枢纽点）—— 找出价格的高低转折点，就像山脉的山顶和山谷
  ↓
Pen（笔）—— 把相邻的山顶和山谷连成线段，每一段就是一"笔"
  ↓
Zhongshu（中枢）—— 找出几笔之间的重叠区域，价格在这里反复震荡
  ↓
Anchor（锚点）—— 标记关键的买卖位置
```

这就像一条食品加工流水线：
- 小麦 → 磨成面粉（Pivot：从 K 线里找转折点）
- 面粉 → 揉成面团（Pen：把转折点连成趋势段）
- 面团 → 做成面包（Zhongshu：找出震荡区间）
- 面包 → 包装贴标签（Anchor：标记关键位置）

每一步都依赖上一步的产物。你不能跳过"磨面粉"直接"揉面团"。

代码里，这条流水线由 `FactorOrchestrator`（因子编排器）驱动。它的 `ingest_closed` 方法就是"开动流水线"的按钮：

```python
# 因子编排器：按顺序跑 pivot → pen → zhongshu → anchor
result = self._factor_orchestrator.ingest_closed(
    series_id=series_id,
    up_to_candle_time=up_to_time,
)
```

每一步的计算结果都会存进 `FactorStore`（因子仓库），以"事件"的形式记录。比如"在时间 T，确认了一笔上涨的 Pen"就是一个事件。这些事件只追加、不修改（append-only），就像会计的账本——你可以加新的记录，但不能涂改旧的。

---

## 4. 第四站：覆盖层工厂——把分析结果变成图形

因子算完了，但它们还只是数字和事件。你的眼睛看不懂"在时间 T 确认了一笔 Pen"这种话。

你需要的是图表上的**线段、标记、色块**。

这就是覆盖层（Overlay）干的事。它读取因子的计算结果，翻译成图表指令：

- "从这个点到那个点画一条红线"（一笔下跌）
- "在这个区域画一个蓝色方块"（一个中枢）
- "在这里放一个三角形标记"（一个锚点）

就像建筑师画完了结构图（因子），然后交给渲染师做成效果图（覆盖层）。

```python
# 覆盖层编排器：把因子结果翻译成图表指令
self._overlay_orchestrator.ingest_closed(
    series_id=series_id,
    up_to_candle_time=up_to_time,
)
```

覆盖层指令存在第三个仓库 `OverlayStore` 里。

到这里，后端的三个仓库就齐了：

| 仓库 | 存什么 | 比喻 |
|------|--------|------|
| CandleStore | 原始 K 线 | 面粉仓库 |
| FactorStore | 因子事件和快照 | 半成品仓库 |
| OverlayStore | 图表绘制指令 | 成品仓库 |

---

## 5. 第五站：前端图表——终于到你眼睛了

后端算完了，怎么送到前端？

两条路：

**路线 A：WebSocket 实时推送（看直播）**

后端算完一根 K 线的全部结果后，通过 WebSocket 把"这根 K 线收盘了"这个消息推给所有正在看这个品种的前端。前端收到后，去拉最新的因子数据和覆盖层数据，更新图表。

就像你在看足球直播，进球了（K 线收盘），解说员喊一嗓子（WS 推送），你的屏幕立刻更新比分（图表刷新）。

**路线 B：HTTP 请求（看录像）**

你刚打开页面，或者切换了一个交易对，前端会主动发 HTTP 请求，一次性拉取最近 N 根 K 线和对应的因子、覆盖层数据。

就像你打开一个比赛的录像回放，先加载历史画面，然后再接上直播。

前端用 Lightweight Charts（一个开源图表库）把 K 线画出来，再把覆盖层的线段、标记叠加上去。

```
前端收到的数据：
├── K 线数据 → 画红绿柱子
├── 因子数据 → 知道当前有哪些笔、中枢
└── 覆盖层指令 → 在图表上画线段、方块、标记
```

---

## 6. 完整旅程：五站连起来

现在把五站串成一句话：

> 币安推了一根收盘 K 线 → 存进 K 线仓库 → 因子流水线算出 pivot/pen/zhongshu/anchor → 覆盖层工厂把结果翻译成图表指令 → 前端收到通知，拉取数据，画在屏幕上。

用代码说，就是 `IngestPipeline` 这个类的 `_run_sync` 方法里的四步：

```python
# 第一步：存 K 线（原料入库）
self._store.upsert_many_closed_in_conn(conn, series_id, candles)

# 第二步：跑因子（加工成半成品）
self._factor_orchestrator.ingest_closed(series_id=sid, up_to_candle_time=t)

# 第三步：跑覆盖层（加工成成品）
self._overlay_orchestrator.ingest_closed(series_id=sid, up_to_candle_time=t)

# 第四步：通知前端（成品上架）
await self._hub.publish_closed_batch(series_id=sid, candles=candles)
```

四行代码，就是整个系统的主动脉。

---

## 7. 那个管所有人的"总管"

你可能会问：这些仓库、编排器、流水线，谁来创建它们？谁来把它们组装在一起？

答案是 `AppContainer`——你可以把它理解为**餐厅的总经理**。

开业之前（系统启动时），总经理要做这些事：
- 雇一个仓库管理员（创建 CandleStore）
- 雇一个流水线主管（创建 FactorOrchestrator）
- 雇一个渲染师（创建 OverlayOrchestrator）
- 雇一个广播员（创建 CandleHub）
- 把他们组装成一条流水线（创建 IngestPipeline）

然后把这些人的名片都放在自己的通讯录里（AppContainer 的字段），谁需要找谁，都通过总经理介绍。

这就是"依赖注入"——不是每个人自己去找合作伙伴，而是总经理统一分配。好处是：换人的时候只改总经理的通讯录，不用改每个人的代码。

---

## 8. 前端那边的"地图"

后端是数据加工厂，前端是展示厅。展示厅的布局是这样的：

```
App.tsx（路由）
├── /live     → LivePage（实时行情）  ← 你最常用的
├── /replay   → ReplayPage（复盘回放）
├── /backtest → BacktestPage（回测）
└── /settings → SettingsPage（设置）
```

每个页面共享同一个外壳（AppShell），里面有：
- 顶部栏（TopBar）：选交易对、选时间框架
- 侧边栏（Sidebar）：市场列表、策略配置
- 图表区（ChartPanel → ChartView）：核心，画 K 线和覆盖层
- 底部栏（BottomTabs）：日志、信号、订单

状态管理用 Zustand（一个轻量级状态库），分成三个 store：
- `uiStore`：UI 偏好（选了哪个交易对、侧边栏开没开）
- `factorStore`：因子显示开关（要不要显示笔、要不要显示中枢）
- `replayStore`：回放状态（播放到第几根、速度多快）

---

## 9. 这套设计背后的三条铁律

走完全程，你会发现整个系统遵守三条铁律：

**铁律一：Closed 才算数**

只有收盘的 K 线才进计算。正在跳动的 K 线只用来看，不用来算。这保证了"同样的输入永远得到同样的输出"——可复现性。

**铁律二：先存后算**

K 线先存进仓库，再进流水线。这样即使流水线崩了，原料还在，修好了可以重新算。

**铁律三：写和读分开**

写数据（IngestPipeline）和读数据（各种 ReadService）是两条独立的路。写的时候不用管谁在读，读的时候不用管谁在写。就像仓库的进货口和出货口分开，互不干扰。

---

## 10. 代码锚点（想验证就去看这些文件）

| 站点 | 文件 | 干什么的 |
|------|------|---------|
| 1号站 | `backend/app/ingest_binance_ws.py` | 接收币安 WebSocket 数据 |
| 2号站 | `backend/app/store.py` | K 线仓库（CandleStore） |
| 3号站 | `backend/app/factor_orchestrator.py` | 因子流水线编排 |
| 4号站 | `backend/app/overlay_orchestrator.py` | 覆盖层工厂 |
| 5号站 | `frontend/src/widgets/ChartView.tsx` | 前端图表渲染 |
| 总管 | `backend/app/container.py` | 系统装配（AppContainer） |
| 流水线 | `backend/app/pipelines/ingest_pipeline.py` | 写链路四步曲 |
| 前端路由 | `frontend/src/App.tsx` | 页面入口 |

---

## 11. 过关自测

如果你能用自己的话回答这五个问题，第 1 关就过了：

1. 为什么 `forming` K 线不能进因子计算？用考试的比喻解释。
2. 为什么 K 线要"先存后算"，而不是"边算边存"？用面包店的比喻解释。
3. `IngestPipeline` 的四步是什么？每一步出错了会怎样？
4. 后端的三个仓库分别存什么？为什么要分开存而不是放一个库里？
5. 前端通过哪两条路拿到后端的数据？它们分别适合什么场景？
